# COIL Memory Model

**TODO: Heap in this document is slightly confusing to some thinking that heap is considered in COIL, Heap should not be ever mentioned in COIL it is a symptom of the standard library and operating system allocation and should be removed from not only here but everywhere in the COIL documentation** 

## Overview

The COIL Memory Model defines how programs interact with memory, providing a consistent abstraction across different hardware platforms while allowing for platform-specific optimizations.

## Memory Organization

COIL organizes memory into logical regions:

```
+----------------+ High Address
| Stack          |
|                |
+----------------+
|     ↓          |
|                |
|     ↑          |
|                |
+----------------+
| Heap           |
|                |
+----------------+
| Global Data    |
| - Initialized  |
| - Uninitialized|
+----------------+
| Program Code   |
|                |
+----------------+ Low Address
```

### Memory Regions

1. **Program Code**: Contains executable instructions
   - Read-only and executable
   - Fixed size determined at compile-time
   - Typically mapped to lower addresses

2. **Global Data**: Contains program-wide variables
   - Subdivided into initialized and uninitialized (BSS) segments
   - Fixed size determined at compile-time
   - Read-write permissions

3. **Heap**: Dynamic memory allocation region
   - Grows upward from lower to higher addresses
   - Variable size, expands as needed
   - Managed through standard library allocation functions
   - Not directly managed by the COIL language itself

4. **Stack**: Function call stack and local variables
   - Grows downward from higher to lower addresses by default (configurable)
   - Automatic allocation and deallocation with function scope
   - Limited size, typically fixed at program start

## Memory Models

COIL supports multiple memory protection models:

### Protected Memory

Default model with access protection:

- Memory regions have distinct permissions (read, write, execute)
- Accesses outside allocated regions raise exceptions
- Stack and buffer overflow protection
- Hardware Memory Management Unit (MMU) support

**Implementation Requirements:**
1. **Permission Flags**: Memory protections are represented as flags in section headers:
   - `READ` (0x01): Page is readable
   - `WRITE` (0x02): Page is writable
   - `EXEC` (0x04): Page is executable

2. **Page Granularity**: Protections apply at page granularity (typically 4KB)

3. **Protection Violations**: When detected, must:
   - Generate a specific exception type (MEMORY_PROTECTION_VIOLATION)
   - Include fault address and attempted access type in exception
   - Terminate execution or transfer to exception handler

4. **Permission Transitions**: Changing permissions requires explicit OS calls
   - Not directly accessible from COIL code
   - Implemented through system library

### Flat Memory

Simple model without protection:

- Single address space with no permissions
- No overflow detection
- Suitable for embedded systems without MMU
- More efficient but less safe

**Implementation Requirements:**
1. **Direct Access**: All memory addresses are directly accessible
2. **No Bounds Checking**: No runtime bounds checking performed
3. **Optimization**: More aggressive optimizations allowed
4. **Platform Restriction**: Limited to platforms without MMU

### Segmented Memory

Model with explicit segments:

- Memory divided into logical segments (code, data, stack)
- Explicit segment selection for memory operations
- Compatible with segmented architectures
- Supports legacy systems

**Implementation Requirements:**
1. **Segment Registers**: Platform-specific segment registers or equivalent
2. **Segment Encoding**: Instructions encode segment identifier
3. **Bounds Checking**: Segment bounds are enforced
4. **Implementation Mapping**: Maps to hardware segmentation where available

## Memory Protection Implementation

Memory protection mechanisms are implemented through:

1. **Hardware MMU**: For protected memory model
   - Page tables map virtual to physical addresses
   - Protection bits in page table entries
   - Page fault handling for violations

2. **Software Checks**: When hardware support is lacking
   - Bounds checking on memory accesses
   - Read/write tracking for regions
   - Higher overhead than hardware protection

3. **Protection Representation in Object Files**:
   - Protection flags in section headers
   - Read, write, execute bits
   - Process-specific rather than thread-specific
   - Inherited by child processes

4. **Protection Error Handling**:
   - Standard exception mechanism
   - Error codes for different violation types
   - Optional error recovery

## Memory Allocation Semantics

### Stack Allocation

Stack memory is managed through:

1. **Function Prologue/Epilogue**:
   - Automatically generated by compiler
   - Allocates space for local variables
   - Adjusts stack pointer on entry/exit

2. **Stack Frames**:
   - Contains return address, saved registers, local variables
   - Implementation-defined layout based on ABI
   - Must preserve alignment requirements

3. **Stack Growth Direction**:
   - Default: Downward (toward lower addresses)
   - Configurable in platform configuration

4. **Stack Size Limits**:
   - Fixed at process start
   - Size defined in configuration or by OS
   - Stack overflow detection where possible

5. **Red Zone**:
   - Optional region below stack pointer
   - Size defined in ABI configuration
   - Safe to use without adjusting stack pointer
   - Not guaranteed to be preserved across calls

### Variable Scoping

Variables have explicit scope defined by SCOPE/SCOPL instructions:

1. **Global Scope**:
   - Accessible throughout the program
   - Allocated in .data or .bss section
   - Initialized at program start

2. **Function Scope**:
   - Limited to the function
   - Allocated on stack by default
   - Initialized on each function entry
   - Destroyed on function exit

3. **Block Scope**:
   - Limited to the defined block
   - Allocated on stack
   - Exists between SCOPE and SCOPL
   - Variables are automatically destroyed when leaving scope

4. **Scope Implementation**:
   - Scope entries maintained in a stack
   - Each entry tracks variables created in that scope
   - When scope ends, all variables in the current scope are destroyed
   - Destruction includes calling finalizers for complex types

## Addressing Modes

COIL supports various memory addressing modes:

1. **Direct**: Access memory at a specific address
   - Example: `[0x1000]`
   - Binary encoding: `[mem_type][address]`

2. **Variable**: Direct reference to a variable
   - Example: `var_id`
   - Binary encoding: `[var_type][var_id]`

3. **Variable Indirect**: Use address from a variable
   - Example: `[var_id]`
   - Binary encoding: `[mem_type][var_type][var_id]`

4. **Based**: Variable plus offset
   - Example: `[var_id + 8]`
   - Binary encoding: `[mem_type][var_type][var_id][imm_type][offset]`

5. **Indexed**: Base variable plus index variable (optionally scaled)
   - Example: `[base + index * scale]`
   - Binary encoding: `[mem_type][var_type][base_id][var_type][index_id][imm_type][scale]`

6. **Based Indexed**: Base variable plus index variable plus offset
   - Example: `[base + index * scale + offset]`
   - Binary encoding: `[mem_type][var_type][base_id][var_type][index_id][imm_type][scale][imm_type][offset]`

## Memory Alignment

Memory alignment requirements are specified in the configuration:

1. **Natural Alignment**:
   - By default, data is aligned to its natural boundary:
     - 1-byte values: 1-byte alignment
     - 2-byte values: 2-byte alignment
     - 4-byte values: 4-byte alignment
     - 8-byte values: 8-byte alignment
     - 16-byte values and larger: 16-byte alignment

2. **Structure Alignment**:
   - Structures align to their largest member by default
   - Padding inserted between members as needed
   - Total structure size is rounded up to alignment boundary

3. **Explicit Alignment Control**:
   - Types can request specific alignment requirements
   - Alignment must be power of 2
   - Maximum alignment is platform-specific

4. **Performance Implications**:
   - Misaligned access may cause performance penalty
   - Some architectures generate exceptions for misaligned access
   - Optimizations may depend on alignment guarantees

## Endianness

Memory byte order is specified in the configuration:

1. **Little Endian**: Least significant byte at lowest address
   - Default for x86, ARM (most modes), RISC-V
   - Example: 0x1234 stored as [0x34, 0x12]

2. **Big Endian**: Most significant byte at lowest address
   - Used in some network protocols, SPARC, older PowerPC
   - Example: 0x1234 stored as [0x12, 0x34]

3. **Mixed Endian**: Platform-specific ordering
   - Rare, usually legacy systems
   - Byte swapping depends on data type

4. **Endianness Conversion**:
   - Explicit conversion functions provided by standard library
   - Binary format includes endianness marker
   - Network protocols typically use big-endian (network byte order)

## Threading Model

For multi-threaded environments:

1. **Thread Memory Isolation**:
   - Each thread has its own stack
   - Stack size configured per thread
   - Thread-local storage for thread-specific data

2. **Shared Memory**:
   - Heap is shared between threads
   - Global data is shared unless specified as thread-local
   - Shared access requires synchronization

3. **Thread-Local Storage (TLS)**:
   - Allows per-thread global variables
   - Implementation is platform-specific
   - Accessible via special TLS addressing mode

4. **Synchronization Primitives**:
   - Not part of the core language
   - Provided by standard library
   - Include atomic operations, locks, barriers

## Memory Consistency

COIL defines memory ordering guarantees:

1. **Sequential Consistency**:
   - Default model for synchronized operations
   - All processors see the same order of operations
   - Strong guarantee but potentially lower performance

2. **Relaxed Ordering**:
   - Available for performance-critical operations
   - Weaker guarantees allow hardware optimization
   - Programmer must use explicit synchronization

3. **Memory Barriers**:
   - Explicit barriers for ordering control
   - Types: full barrier, acquire, release, consume
   - Platform-specific implementation

4. **Atomic Operations**:
   - Thread-safe memory modifications
   - ATOMIC flag enables atomicity
   - Includes read-modify-write operations

## Error Handling

Memory-related errors are handled through these mechanisms:

1. **Null Pointer Access**:
   - Dereferencing null (0) pointer raises exception
   - Exception type: NULL_POINTER_EXCEPTION
   - Cannot be disabled even in flat memory model

2. **Out of Bounds Access**:
   - Accessing memory outside allocated region
   - Exception type: BOUNDS_VIOLATION
   - May only be detected in protected memory model

3. **Protection Violation**:
   - Accessing memory without proper permissions
   - Exception type: PROTECTION_VIOLATION
   - Includes type (read/write/execute)

4. **Stack Overflow**:
   - Exceeding stack size limit
   - Exception type: STACK_OVERFLOW
   - May be handled by OS or runtime

5. **Out of Memory**:
   - Failure to allocate requested memory
   - Exception type: OUT_OF_MEMORY
   - Raised by allocation operations

## Memory Layout Control

COIL provides mechanisms to control memory layout:

1. **Section Directives**:
   - SECT directive defines sections
   - Controls placement and attributes
   - Example: `SECT ".data.constants", READ`

2. **Alignment Control**:
   - PADD directive for explicit padding
   - Alignment can be specified for sections
   - Example: `PADD 16` (align to 16-byte boundary)

3. **Memory Mapping**:
   - OS-specific memory mapping
   - Implemented through standard library
   - Control over address ranges and permissions

## Implementation Requirements

Conforming implementations must:

1. Support at least the Protected Memory Model
2. Correctly handle all addressing modes
3. Implement variable scoping with SCOPE/SCOPL
4. Respect alignment requirements
5. Properly handle endianness conversion
6. Generate appropriate exceptions for memory errors

## Related Components

- [Object Format](../format/object-format.md) - Object file organization
- [Linking Model](./linking-model.md) - Memory layout during linking
- [Memory Operations](../isa-u/memory-operations.md) - Memory management instructions
- [Configuration Format](./config-format.md) - Memory model configuration