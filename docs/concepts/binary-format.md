# COIL Binary Format

## Purpose

This document defines the foundational binary format of COIL instructions. COIL is fundamentally a binary instruction format designed to be generated by compilers and processed by COIL processors. This specification establishes how instructions, operands, and types are encoded in their binary form.

## Instruction Encoding

COIL instructions follow a consistent binary format:

```
[Opcode (8 bits)] [Operand Count (8 bits)] [Operands...]
```

Each operand consists of:
```
[Type (16 bits)] [Type-Specific Data (variable)] [Value (variable)]
```

### Opcode Field

The opcode field is a single byte that identifies the operation to perform:

```
0x00      - No Operation
0x01-0x0F - Control Flow
0x10-0x2F - Memory Operations
0x30-0x4F - Reserved for Multi-Device Operations (v3)
0x50-0x5F - Bit Manipulation
0x60-0x8F - Arithmetic
0x90-0x9F - Vector/Array Operations
0xA0-0xAF - Type Instructions
0xB0-0xBF - Directive Instructions
0xC0-0xFE - Architecture/Processor-Specific Instructions
0xFF      - COIL Processor-Specific Extensions
```

### Operand Count

A single byte indicating how many operands follow the instruction:

```
0x00 - Zero operands
0x01 - One operand
0x02 - Two operands
...
```

Most instructions have a fixed number of operands, but some (like `CALL` with parameters) may have a variable number.

### Type Field

The type field is a 16-bit value divided into two parts:
- First 8 bits: Main Type - Identifies the primary type
- Second 8 bits: Type Extensions - Provides qualifiers and additional information

Example type fields:
```
0x0300 - TYPE_INT32 (32-bit signed integer)
0x0301 - TYPE_INT32+CONST (constant 32-bit signed integer)
0x1400 - TYPE_UNT64 (64-bit unsigned integer)
0x9200 - TYPE_RGP (general purpose register)
```

See the [Type System Specification](spec/core/type-system.md) for the complete list of types and extensions.

### Type-Specific Data

Some types require additional data beyond the 16-bit type descriptor:

1. **Register types** include a register identifier after the type field:
   ```
   0x9200 0x05    ; TYPE_RGP=RDI (on x86-64)
   ```

2. **Composite types** include additional type information:
   ```
   0xD300 0x1000  ; TYPE_ARRAY=TYPE_UNT8
   ```

3. **Parameter types** include parameter-specific data:
   ```
   0xF800 0x0100 [ABI_ID]  ; TYPE_ABICTL=ABICTL_PARAM=abi_name
   ```

The size and format of type-specific data depends on the specific type.

### Value Field

The value field contains the actual data for the operand. Its size and encoding depend on the type:

1. **Immediate integer values** are encoded in little-endian format:
   ```
   0x1320 0x2A000000  ; TYPE_UNT32+IMM with value 42
   ```

2. **Floating-point values** use IEEE format:
   ```
   0x2520 [IEEE 754 encoding]  ; TYPE_FP32+IMM with floating-point value
   ```

3. **Symbol references** include a symbol ID:
   ```
   0x9100 [symbol_id]  ; TYPE_SYM with symbol ID
   ```

4. **Variable references** include a variable ID:
   ```
   0x9000 [variable_id]  ; TYPE_VAR with variable ID
   ```

The size of the value field varies based on the type and type extensions.

## Encoding Examples

### Basic Instruction

```
; COIL-ASM:
MOV TYPE_RGP=RAX, 42

; Binary Encoding:
0x10            ; Opcode for MOV
0x02            ; Two operands
0x9200          ; TYPE_RGP
0x00            ; Register ID for RAX
0x1320          ; TYPE_UNT32+IMM
0x2A000000      ; Value 42 (little-endian)
```

### Variable Declaration

```
; COIL-ASM:
VAR TYPE_INT32, counter, 10

; Binary Encoding:
0x16            ; Opcode for VAR
0x03            ; Three operands
0x0300          ; TYPE_INT32
0x9100          ; TYPE_SYM for name
[sym_id]        ; Symbol ID for "counter"
0x1320          ; TYPE_UNT32+IMM
0x0A000000      ; Value 10 (little-endian)
```

### Function Call with ABI

```
; COIL-ASM:
CALL add_function, TYPE_ABICTL=ABICTL_PARAM=linux_x86_64, x

; Binary Encoding:
0x03            ; Opcode for CALL
0x03            ; Three operands
0x9100          ; TYPE_SYM for function name
[sym_id]        ; Symbol ID for add_function
0xF800          ; TYPE_ABICTL
0x0100          ; ABICTL_PARAM
[abi_id]        ; ABI ID for linux_x86_64
0x9000          ; TYPE_VAR for x
[var_id]        ; Variable ID for x
```

### Conditional Branch

```
; COIL-ASM:
BR_EQ equal_handler

; Binary Encoding:
0x02            ; Opcode for BR
0x02            ; Two operands
0x9100          ; TYPE_SYM for target
[sym_id]        ; Symbol ID for equal_handler
0xF005          ; TYPE_PARAM5 with branch condition
0x0000          ; BRANCH_COND_EQ
```

## Alignment and Padding

The binary format adheres to the following alignment rules:

1. Instructions are not required to be aligned on any particular boundary
2. Multi-byte values in operands follow the endianness of the target platform (little-endian by default)
3. No padding is inserted between instruction fields
4. No padding is inserted between instructions

## Special Encoding Considerations

### ABI Directive

When the `ABI` directive is encountered, the instruction set temporarily changes to a special set of ABI definition opcodes until the `EXIT` opcode is encountered:

```
0xBA            ; Opcode for ABI
0x01            ; One operand
0x9100          ; TYPE_SYM for ABI name
[sym_id]        ; Symbol ID for ABI name

; ABI-specific instructions follow until EXIT
```

### Conditional Assembly

Conditional assembly directives (`IF`, `ELIF`, `ELSE`, `ENDIF`) are processed during assembly and do not appear in the final binary format.

## Binary Format Benefits

The COIL binary format is designed with several advantages:

1. **Compact representation**: The type-determined instruction approach reduces the number of opcodes needed
2. **Type safety**: Explicit type information enables better validation and error checking
3. **Extensibility**: The format can accommodate new types and operations without breaking compatibility
4. **Processor independence**: The encoding is not tied to any specific processor architecture
5. **Direct mapping**: Each text instruction maps directly to one binary instruction