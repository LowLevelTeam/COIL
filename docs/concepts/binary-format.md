# COIL Binary Format

## Purpose

This document defines the foundational binary format of COIL instructions. COIL is fundamentally a binary instruction format designed to be generated by compilers and processed by COIL processors.

## Binary Format Primacy

COIL is designed with binary format primacy as a core principle. This means:

1. The binary representation is the authoritative definition of COIL
2. The text representation (COIL-ASM) is a human-readable interface to this binary format
3. Each text instruction maps directly to one binary instruction
4. All tools operate on the binary format as the ground truth

This approach ensures clarity in the specification, simplifies implementation of tools, and provides a solid foundation for portability.

## Instruction Format Overview

Every COIL instruction is encoded as a sequence of bytes following this structure:

```
[Opcode (8 bits)] [Operand Count (8 bits)] [Operands...]
```

The opcode identifies the operation to perform, while the operand count indicates how many operands follow. This simple format allows for variable-length instructions while maintaining consistent parsing.

## Operand Encoding

Each operand is encoded as:

```
[Type (16 bits)] [Type-Specific Data (variable)] [Value (variable)]
```

The type field determines:
- How the operand value is interpreted
- What operations can be performed on it
- The size and format of any type-specific data
- The size and format of the value field

This type-first approach is key to COIL's type-determined instruction philosophy.

## Type Encoding

The type field is a 16-bit value divided into two parts:
- First 8 bits: Main Type - Identifies the primary type category
- Second 8 bits: Type Extensions - Provides qualifiers (const, volatile, etc.)

Type extensions are bit flags that modify the behavior of the base type:
```
TYPEEXT_CONST    = 0x01  // Constant value (read-only)
TYPEEXT_VOLATILE = 0x02  // Volatile access (not optimizable)
TYPEEXT_VOID     = 0x10  // No Value
TYPEEXT_IMM      = 0x20  // Immediate value
TYPEEXT_VAR      = 0x40  // Variable ID
TYPEEXT_SYM      = 0x80  // Symbol ID
```

## Extending the Format

The binary format is designed for extensibility:

1. **Type Data Extensions**:
   - Complex types can include additional type information
   - Register types include register identifiers
   - Composite types include structure definitions

2. **New Type Definitions**:
   - New main types can be added in future versions
   - Type extensions can be expanded with additional flags
   - Type-specific data formats can evolve

3. **Instruction Extensions**:
   - Reserved opcode ranges for processor-specific instructions
   - Extension opcodes for implementation-specific features
   - Parameter types for instruction modifiers

## Endianness and Alignment

The binary format makes these guarantees:

1. **Instruction Alignment**: Instructions are not required to be aligned on any particular boundary
2. **Value Endianness**: Multi-byte values in operands follow little-endian encoding by default
3. **No Padding**: No padding is inserted between instruction fields or between instructions

## Format Benefits

The COIL binary format is designed with several advantages:

1. **Compact representation**: The type-determined instruction approach reduces the number of opcodes needed
2. **Type safety**: Explicit type information enables better validation and error checking
3. **Extensibility**: The format can accommodate new types and operations without breaking compatibility
4. **Processor independence**: The encoding is not tied to any specific processor architecture
5. **Direct mapping**: Each text instruction maps directly to one binary instruction

## Related Documentation

For more detailed information on specific aspects of the binary format, see:
- [Binary Encoding](../isa/binary-encoding.md) - Detailed encoding rules for instructions
- [Type System](type-system.md) - Type encoding details
- [Object Format](../implementation/object-format.md) - File format specification