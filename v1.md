# COIL v1 Specification

## 1. Introduction

The Computer Oriented Intermediate Language (COIL) version 1 defines a complete Instruction Set Architecture (ISA) capable of targeting any single processing unit. This specification establishes the foundational binary format, instruction set, and type system that enables portable code generation across diverse architectures while maintaining native performance characteristics.

COIL follows a type-determined instruction philosophy where behavior is inferred from operand types, enabling compact representation while maintaining expressive power. This specification defines the complete framework for implementing, extending, and utilizing COIL in software and hardware environments.

### 1.1 Design Philosophy

COIL is built on several foundational principles:

#### 1.1.1 Type-Determined Instruction Philosophy

Instructions in COIL derive their behavior from the types of their operands, rather than having numerous specialized opcodes. This allows for:

- Compact binary representation
- Consistent behavior across data types
- Extensibility without opcode explosion
- Simplified instruction decoding

#### 1.1.2 Architecture Independence

COIL maintains a clean separation between:

- Universal operations (available on all platforms)
- Processing unit specific operations
- Architecture specific operations
- Implementation specific extensions

This separation ensures maximum portability while still allowing direct access to hardware-specific features when needed.

#### 1.1.3 Performance-First Approach

COIL is designed to compile efficiently to native code without sacrificing performance:

- No abstraction penalties for universal operations
- Direct mapping to hardware capabilities where possible
- Optimization hints through type extensions
- Explicit control over performance-critical aspects

### 1.2 Scope of v1

COIL v1 is focused on:
- Support for single processing unit targeting
- Complete type system and instruction set
- Foundational binary formats
- Basic Application Binary Interface (ABI) mechanisms

Future versions will extend COIL to support:
- Multi-device coordination (v3)
- Standard library (v2)
- Cross-architecture optimizations

## 2. Binary Encoding

### 2.1 Instruction Format

COIL instructions follow a consistent binary format:

```
[Opcode (8 bits)] [Operand Count (8 bits)] [Operands...]
```

Each operand consists of:
```
[Type (16 bits)] [Type-Specific Data (variable)] [Value (variable)]
```

The Type field is composed of:
- Main Type (8 bits) - Defines the primary type category
- Type Extensions (8 bits) - Provides qualifiers and additional type information

### 2.2 Opcode Organization

The 8-bit opcode space is organized into functional categories:

```
0x00      - No Operation
0x01-0x0F - Control Flow
0x10-0x2F - Memory Operations
0x30-0x4F - Reserved for Multi-Device Operations (v3)
0x50-0x5F - Bit Manipulation
0x60-0x8F - Arithmetic
0x90-0x9F - Vector/Array Operations
0xA0-0xAF - Type Instructions
0xB0-0xBF - Directive Instructions
0xC0-0xFE - Architecture/Processor-Specific Instructions
0xFF      - COIL Processor-Specific Extensions
```

#### 2.2.1 Reserved Instruction Space

The range 0x30-0x4F is intentionally reserved in COIL v1 for future multi-device operations in COIL v3. This space will later include instructions for:

- Device selection and switching
- Cross-device memory transfers
- Synchronization between devices
- Parallel execution coordination
- Device capability queries
- Queue and workgroup management

Attempting to use opcodes in this range in v1 will result in an invalid instruction error.

## 3. Type System

The type system is encoded in 16 bits, with the first 8 bits representing the main type and the second 8 bits representing type extensions.

### 3.1 Main Types (First 8 bits)

```
// Fixed width signed integers
0x01-0x05 - TYPE_INT8 through TYPE_INT128

// Fixed width unsigned integers
0x10-0x15 - TYPE_UNT8 through TYPE_UNT128
  
// Fixed width floating point
0x20-0x28 - TYPE_FP8e5m2 through TYPE_FP128

// Fixed Width Vectors
0x30-0x32 - TYPE_V128 through TYPE_V512

// Boolean type
0x40      - TYPE_BIT (1-bit boolean)

// COIL Special Types
0x90-0x9C - Register and state types

// Platform Dependent Types
0xA0-0xA6 - Platform-specific size types

// Complex Types
0xB0-0xB2 - Complex number types

// Composite Types
0xD0-0xD3 - Structure, union, array types

// Parameter Types
0xF0-0xFE - TYPE_PARAM0 through TYPE_PARAM5

// Void Type
0xFF      - TYPE_VOID
```

Detailed type listings:

```
// Fixed width signed integers
TYPE_INT8   = 0x01  // 8-bit signed integer
TYPE_INT16  = 0x02  // 16-bit signed integer
TYPE_INT32  = 0x03  // 32-bit signed integer
TYPE_INT64  = 0x04  // 64-bit signed integer
TYPE_INT128 = 0x05  // 128-bit signed integer

// Fixed width unsigned integers
TYPE_UNT8   = 0x10  // 8-bit unsigned integer
TYPE_UNT16  = 0x12  // 16-bit unsigned integer
TYPE_UNT32  = 0x13  // 32-bit unsigned integer
TYPE_UNT64  = 0x14  // 64-bit unsigned integer
TYPE_UNT128 = 0x15  // 128-bit unsigned integer
  
// Fixed width floating point
TYPE_FP8e5m2 = 0x20  // 8-bit float (5-bit exponent, 2-bit mantissa)
TYPE_FP8e4m3 = 0x21  // 8-bit float (4-bit exponent, 3-bit mantissa)
TYPE_FP16b   = 0x22  // bfloat16
TYPE_FP16    = 0x23  // IEEE 754 half precision
TYPE_FP32t   = 0x24  // tensor float 32
TYPE_FP32    = 0x25  // IEEE 754 single precision
TYPE_FP64    = 0x26  // IEEE 754 double precision
TYPE_FP80    = 0x27  // x87 extended precision
TYPE_FP128   = 0x28  // IEEE 754 quadruple precision

// Fixed Width Vectors
TYPE_V128 = 0x30  // 128-bit vector
TYPE_V256 = 0x31  // 256-bit vector
TYPE_V512 = 0x32  // 512-bit vector

// Boolean type
TYPE_BIT = 0x40  // 1-bit boolean, special type to allow for creating bitmaps behind the scenes 

// COIL Special Types
TYPE_VAR = 0x90  // Value is a variable ID
TYPE_SYM = 0x91  // Value is a symbol rather than value at symbol
TYPE_RGP = 0x92  // Register general purpose
TYPE_RFP = 0x93  // Register floating point
TYPE_RV  = 0x94  // Register vector
TYPE_RS  = 0x95  // Register segment
TYPE_SAR = 0x96  // State - all registers
TYPE_SAF = 0x97  // State - all flags
TYPE_SES = 0x98  // State - extended processor state
TYPE_SS  = 0x99  // State - complete state
TYPE_IP  = 0x9A  // Register Instruction Pointer
TYPE_SP  = 0x9B  // Register Stack Pointer
TYPE_BP  = 0x9C  // Register Base Pointer

// Platform Dependent Types
TYPE_INT  = 0xA0  // Default integer for current platform
TYPE_UNT  = 0xA1  // Default unsigned for current platform
TYPE_FP   = 0xA2  // Default float for current platform
TYPE_LINT = 0xA3  // Largest integer for current platform
TYPE_LUNT = 0xA4  // Largest unsigned for current platform
TYPE_LFP  = 0xA5  // Largest float point for current platform
TYPE_PTR  = 0xA6  // Default pointer size for current platform

// Complex Types
TYPE_CINT = 0xB0  // Complex integer
TYPE_CUNT = 0xB1  // Complex unsigned (pronounced (see-unt))
TYPE_CFP  = 0xB2  // Complex floating point

// Composite Types
TYPE_STRUCT = 0xD0  // Structure type
TYPE_PACK   = 0xD1  // Packed structure (no padding)
TYPE_UNION  = 0xD2  // Union type
TYPE_ARRAY  = 0xD3  // Array type

// Parameter Types
TYPE_PARAM5 = 0xF0  // Parameter type 5
TYPE_PARAM4 = 0xFA  // Parameter type 4
TYPE_PARAM3 = 0xFB  // Parameter type 3
TYPE_PARAM2 = 0xFC  // Parameter type 2
TYPE_PARAM1 = 0xFD  // Parameter type 1
TYPE_PARAM0 = 0xFE  // Parameter type 0

// Void Type
TYPE_VOID = 0xFF  // Void type (no value)
```

### 3.2 Type Extensions (Second 8 bits)

```
0x01 - TYPEEXT_CONST    - Constant value (read-only)
0x02 - TYPEEXT_VOLATILE - Volatile access (not optimizable)
0x10 - TYPEEXT_VOID     - No Value
0x20 - TYPEEXT_IMM      - Immediate value
0x40 - TYPEEXT_VAR      - Variable ID
0x80 - TYPEEXT_SYM      - Symbol ID
```

Type extensions provide additional qualifiers for type values:

```
TYPEEXT_CONST    = (1 << 0)  // 0x01 - Constant value (read-only)
TYPEEXT_VOLATILE = (1 << 1)  // 0x02 - Volatile access (not optimizable)
TYPEEXT_VOID     = (1 << 4)  // 0x10 - No Value
TYPEEXT_IMM      = (1 << 5)  // 0x20 - Immediate value
TYPEEXT_VAR      = (1 << 6)  // 0x40 - Variable ID
TYPEEXT_SYM      = (1 << 7)  // 0x80 - Symbol ID
```

Where the type defines the underlying type, the type extension not only gives hints about the type but also provides the format of the type's encoding.

### 3.3 Parameter Definitions

Parameters modify instruction behavior and provide additional context for operations.

#### 3.3.1 symbol_parameter0_t
```
TMP  = 0x00 // symbol is used only in this context
FILE = 0x01 // symbol is used around the file
GLOB = 0x02 // symbol is used in other files
```

#### 3.3.2 branch_condition_t
```
BRANCH_COND_EQ = 0x00  // Equal
BRANCH_COND_NE = 0x01  // Not equal
BRANCH_COND_GE = 0x02  // Greater than or equal
BRANCH_COND_LT = 0x03  // Less than
BRANCH_COND_GT = 0x04  // Greater than
BRANCH_COND_LE = 0x05  // Less than or equal
BRANCH_COND_Z  = 0x06  // Zero flag set
BRANCH_COND_NZ = 0x07  // Zero flag not set
BRANCH_COND_C  = 0x08  // Carry flag set
BRANCH_COND_NC = 0x09  // Carry flag not set
BRANCH_COND_O  = 0x0A  // Overflow flag set
BRANCH_COND_NO = 0x0B  // Overflow flag not set
BRANCH_COND_S  = 0x0C  // Sign flag set
BRANCH_COND_NS = 0x0D  // Sign flag not set
```

#### 3.3.3 branch_ctrl_t
```
BRANCH_CTRL_FAR       = 0x00  // Far jump/call
BRANCH_CTRL_INL       = 0x01  // Inline
BRANCH_CTRL_ABI       = 0x02  // Use ABI conventions
BRANCH_CTRL_ABI_PARAM = 0x03  // Following operands are parameters
BRANCH_CTRL_ABI_RET   = 0x04  // Following operands are return destinations
```

#### 3.3.4 Memory Control
```
MEMORY_CTRL_ATOMIC    = 0x01  // Atomic operation
MEMORY_CTRL_VOLATILE  = 0x02  // Volatile access
MEMORY_CTRL_ALIGNED   = 0x03  // Enforce alignment
MEMORY_CTRL_UNALIGNED = 0x04  // Allow unaligned access
```

## 4. Core Instruction Set

### 4.1 Control Flow (0x01-0x0F)

Core instructions for program flow control:

#### 4.1.1 SYM (0x01)
Define a symbol. Worked out by either the linker or attempted to be worked out at COIL processor compilation into a program address.

Symbols should be defined with either no ABI or an ABI id. If no ABI then the following is not used. If an ABI then you can define parameters with types and a variable identifier and then define the return values.

```
Operands:
- Symbol: TYPE_SYM
- TYPE_PARAM0: symbol_parameter0_t (optional)
```

#### 4.1.2 BR (0x02)
Branch to a program address with parameters based on an ABI specification.

```
Operands:
- Target: TYPE_PTR | TYPE_SYM | TYPE_*UNT*
- TYPE_PARAM0: branch_ctrl_t (optional)
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.1.3 CALL (0x03)
Enter procedure with parameters based on an ABI specification.

```
Operands:
- Target: TYPE_PTR | TYPE_SYM | TYPE_*UNT*
- TYPE_PARAM0: branch_ctrl_t (optional)
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.1.4 RET (0x04)
Return from procedure.

ABI compatible for returning values according to ABI specification.

```
Operands:
- TYPE_PARAM0: branch_ctrl_t (optional)
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.1.5 CMP (0x05)
Compare values and set flags without changing registers.

```
Operands:
- Left: Non TYPE_VOID
- Right: Non TYPE_VOID
```

#### 4.1.6 TEST (0x06)
Bitwise AND and set flags without changing registers.

```
Operands:
- Left: Non TYPE_VOID
- Right: Non TYPE_VOID
```

### 4.2 Memory Operations (0x10-0x2F)

Instructions for memory access and management:

#### 4.2.1 MOV (0x10)
This function serves to transmit data from multiple formats via a source into a destination.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.2.2 PUSH (0x11)
Push a state onto the stack.
Can be used with variables to demote its position. When pushing a variable the processor will prioritize this variable on the stack and free up a register slot if using one.

```
Operands:
- Source: Non TYPE_VOID, (!TYPEEXT_VAR)
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.2.3 POP (0x12)
Pop a state from the stack.
Can be used with variables to promote its position. When popping a variable the processor will prioritize this variable in a register.

```
Operands:
- Source: Non TYPE_VOID, (!TYPEEXT_VAR)
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.2.4 LEA (0x13)
Load Effective Address - computes the address of a memory operand and stores it in the destination.

```
Operands:
- Destination: Non TYPE_VOID
- Address: Any addressable type
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.2.5 SCOPEE (0x14)
Enter a scope - initializes a new scope for variables.

```
Operands:
- None
```

#### 4.2.6 SCOPEL (0x15)
Leave a scope - cleans up variables in the current scope.

```
Operands:
- None
```

#### 4.2.7 VAR (0x16)
Variable declaration - defines a new variable in the current scope.

```
Operands:
- Type: TYPE_*
- Identifier: TYPE_SYM
- InitialValue: Non TYPE_VOID (optional)
```

#### 4.2.8 MEMCPY (0x17)
Memory copy - copies a block of memory from a source to a destination.

```
Operands:
- Destination: TYPE_PTR
- Source: TYPE_PTR
- Size: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.2.9 MEMSET (0x18)
Memory set - fills a block of memory with a specific value.

```
Operands:
- Destination: TYPE_PTR
- Value: TYPE_UNT8
- Size: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.2.10 MEMCMP (0x19)
Memory compare - compares two blocks of memory and sets flags.

```
Operands:
- Left: TYPE_PTR
- Right: TYPE_PTR
- Size: Non TYPE_VOID
```

#### 4.2.11 XCHG (0x1A)
Exchange - atomically swaps values between two locations.

```
Operands:
- Location1: Non TYPE_VOID
- Location2: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.2.12 CAS (0x1B)
Compare and Swap - atomically compares and conditionally swaps values.

```
Operands:
- Destination: Non TYPE_VOID
- Expected: Non TYPE_VOID
- New: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.2.13 PIN (0x2E)
Pin memory for DMA operations.

```
Operands:
- Address: TYPE_PTR
- Size: TYPE_*UNT*
```

#### 4.2.14 UNPIN (0x2F)
Unpin memory after DMA operations.

```
Operands:
- Address: TYPE_PTR
```

### 4.3 Bit Manipulation (0x50-0x5F)

Instructions for binary operations:

#### 4.3.1 AND (0x50)
Bitwise AND of two values.

```
Operands:
- Destination: Non TYPE_VOID
- Left: Non TYPE_VOID
- Right: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.3.2 OR (0x51)
Bitwise OR of two values.

```
Operands:
- Destination: Non TYPE_VOID
- Left: Non TYPE_VOID
- Right: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.3.3 XOR (0x52)
Bitwise XOR of two values.

```
Operands:
- Destination: Non TYPE_VOID
- Left: Non TYPE_VOID
- Right: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.3.4 NOT (0x53)
Bitwise complement.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.3.5 SHL (0x54)
Logical left shift.

```
Operands:
- Destination: Non TYPE_VOID
- Value: Non TYPE_VOID
- Shift: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.3.6 SHR (0x55)
Logical right shift.

```
Operands:
- Destination: Non TYPE_VOID
- Value: Non TYPE_VOID
- Shift: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.3.7 SAR (0x56)
Arithmetic right shift.

```
Operands:
- Destination: Non TYPE_VOID
- Value: Non TYPE_VOID
- Shift: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.3.8 ROL (0x57)
Rotate left.

```
Operands:
- Destination: Non TYPE_VOID
- Value: Non TYPE_VOID
- Rotate: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.3.9 ROR (0x58)
Rotate right.

```
Operands:
- Destination: Non TYPE_VOID
- Value: Non TYPE_VOID
- Rotate: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.3.10 POPCNT (0x59)
Count set bits (population count).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.3.11 BSWAP (0x5A)
Byte swap (endianness conversion).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

### 4.4 Arithmetic (0x60-0x8F)

Mathematical operations:

#### 4.4.1 ADD (0x60)
Add two values and store the result.

```
Operands:
- Destination: Non TYPE_VOID
- Left: Non TYPE_VOID
- Right: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.4.2 SUB (0x61)
Subtract the second value from the first and store the result.

```
Operands:
- Destination: Non TYPE_VOID
- Left: Non TYPE_VOID
- Right: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.4.3 MUL (0x62)
Multiply two values and store the result.

```
Operands:
- Destination: Non TYPE_VOID
- Left: Non TYPE_VOID
- Right: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.4.4 DIV (0x63)
Divide the first value by the second and store the result.

```
Operands:
- Destination: Non TYPE_VOID
- Left: Non TYPE_VOID
- Right: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.4.5 MOD (0x64)
Compute the remainder of dividing the first value by the second.

```
Operands:
- Destination: Non TYPE_VOID
- Left: Non TYPE_VOID
- Right: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.4.6 INC (0x65)
Increment a value by 1.

```
Operands:
- Destination: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.4.7 DEC (0x66)
Decrement a value by 1.

```
Operands:
- Destination: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.4.8 NEG (0x67)
Negate a value.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.4.9 ABS (0x68)
Compute the absolute value.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.4.10 SQRT (0x69)
Compute the square root.

```
Operands:
- Destination: Non TYPE_VOID (floating-point type)
- Source: Non TYPE_VOID (floating-point type)
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.4.11 FMA (0x6A)
Fused multiply-add: (a * b) + c with a single rounding.

```
Operands:
- Destination: Non TYPE_VOID (floating-point type)
- A: Non TYPE_VOID (floating-point type)
- B: Non TYPE_VOID (floating-point type)
- C: Non TYPE_VOID (floating-point type)
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.4.12 MIN (0x7B)
Compute the minimum of two values.

```
Operands:
- Destination: Non TYPE_VOID
- Left: Non TYPE_VOID
- Right: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.4.13 MAX (0x7C)
Compute the maximum of two values.

```
Operands:
- Destination: Non TYPE_VOID
- Left: Non TYPE_VOID
- Right: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

### 4.5 Vector/Array Operations (0x90-0x9F)

Operations on multiple values:

#### 4.5.1 VDOT (0x95)
Compute the dot product of vectors.

```
Operands:
- Destination: Non TYPE_VOID
- Left: TYPE_V* or TYPE_ARRAY
- Right: TYPE_V* or TYPE_ARRAY
- TYPE_PARAM5: branch_condition_t (optional)
```

### 4.6 Type Instructions (0xA0-0xAF)

Type manipulation:

#### 4.6.1 TYPEOF (0xA0)
Get the type of a value.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Any type
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.6.2 SIZEOF (0xA1)
Get the size of a type or value in bytes.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Any type
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.6.3 ALIGNOF (0xA2)
Get the alignment requirement of a type or value in bytes.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Any type
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.6.4 CONVERT (0xA3)
Convert a value from one type to another with possible precision loss.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.6.5 CAST (0xA4)
Reinterpret a value as another type without changing the bit pattern.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.6.6 STRUCT (0xA5)
Define a structure type.

```
Operands:
- Destination: TYPE_STRUCT
- Field1Type: TYPE_*
- Field1Name: TYPE_SYM
- Field2Type: TYPE_*
- Field2Name: TYPE_SYM
- ...
```

#### 4.6.7 GET (0xA6)
Access a field in a structure or union.

```
Operands:
- Destination: Non TYPE_VOID
- Source: TYPE_STRUCT or TYPE_UNION
- Field: TYPE_SYM
- TYPE_PARAM5: branch_condition_t (optional)
```

#### 4.6.8 INDEX (0xA7)
Access an element in an array.

```
Operands:
- Destination: Non TYPE_VOID
- Source: TYPE_ARRAY
- Index: Non TYPE_VOID
- TYPE_PARAM5: branch_condition_t (optional)
```

### 4.7 Directive Instructions (0xB0-0xBF)

Code generation directives:

#### 4.7.1 ARCH (0xB0)
Set the target architecture. This directive must be preceded by the PROC directive as architecture is a subset of the processing unit.

```
Operands:
- Architecture: TYPE_UNT8 (architecture code)
```

#### 4.7.2 PROC (0xB1)
Set the target processor.

```
Operands:
- Processor: TYPE_UNT8 (processor code)
```

#### 4.7.3 MODE (0xB2)
Set the target processor mode. Use an ID provided by a configuration file to specify different feature sets for the same device. Switching between modes is handled by the user; this just controls the native binary made at each location to align with the specification.

```
Operands:
- Mode: TYPE_UNT8 (mode code)
```

#### 4.7.4 ALIGN (0xB3)
Align the next instruction or data to a specified boundary.
Can be used to pad program to a specified index as needed by specification situations like a x86 BIOS bootloader.

```
Operands:
- Alignment: Non TYPE_VOID
```

#### 4.7.5 SECTION (0xB4)
Define a new section in the output.

```
Operands:
- Name: TYPE_SYM
- Attributes: Non TYPE_VOID
```

#### 4.7.6 DATA (0xB5)
Insert data into program memory.

```
Operands:
- Type: TYPE_*
- Value: Non TYPE_VOID
```

#### 4.7.7 IF (0xB6)
Compilation controlled if statement to help with code inclusion management.

```
Operands:
- Condition: Non TYPE_VOID
```

#### 4.7.8 ELIF (0xB7)
Else-if clause for compilation control.

```
Operands:
- Condition: Non TYPE_VOID
```

#### 4.7.9 ELSE (0xB8)
Else clause for compilation control.

```
Operands:
- None
```

#### 4.7.10 ENDIF (0xB9)
End of conditional compilation block.

```
Operands:
- None
```

#### 4.7.11 ABI (0xBA)
Define an Application Binary Interface (ABI).

```
Operands:
- Name: TYPE_SYM
- ABIDefinition: Multiple ABI-specific instructions
```

### 4.8 Special Instructions (0x00 && 0xC0-0xFF)

#### 4.8.1 NOP (0x00)
No Operation - Does nothing, advances instruction pointer.

```
Format: Single byte with value 0x00 (no operands)
```

#### 4.8.2 Processing Unit Specific Instructions (0xC0-0xDF)

Instructions that are specific to a particular type of processing unit (CPU, GPU, TPU, etc.) but can be implemented across different architectures within that processing unit.

##### 4.8.2.1 CPU Specific Instructions

- Interrupt Control
- System Call Mechanisms
- Privileged Mode Operations
- Memory Management Unit Control
- Cache Control Operations
- Power Management
- Interrupt Table Management

##### 4.8.2.2 GPU Specific Instructions

- Texture Operations
- Shader Control
- Memory Barrier Operations
- Atomic Operations on Shared Memory
- Thread Synchronization

##### 4.8.2.3 TPU/AI Accelerator Specific Instructions

- Matrix Operations
- Tensor Data Movement
- Activation Functions
- Quantization Operations
- Training-Specific Operations

#### 4.8.3 Architecture Specific Instructions (0xE0-0xFE)

Instructions that are specific to a particular architecture within a processing unit type.

##### 4.8.3.1 x86 Architecture Specific Instructions

- x86-specific CPU features
- Specific register manipulations
- Legacy mode instructions
- SIMD extensions (SSE, AVX, etc.)

##### 4.8.3.2 ARM Architecture Specific Instructions

- ARM-specific CPU features
- Conditional execution
- NEON vector operations
- Barrier instructions

##### 4.8.3.3 RISC-V Architecture Specific Instructions

- RISC-V extensions
- Custom instructions
- Vector operations

#### 4.8.4 COIL Processor Specific Extensions (0xFF)

Instructions that are specific to a COIL processor implementation:

```
Operands:
- ExtensionCode: TYPE_UNT8
- Additional operands as defined by the specific extension
```

## 5. Application Binary Interface (ABI)

COIL supports custom calling conventions through ABI definitions:

### 5.1 ABI Definition Format

```
abi definition {
  param_regs: [register list]    // Parameter registers
  return_regs: [register list]   // Return value registers
  caller_saved: [register list]  // Caller-saved registers
  callee_saved: [register list]  // Callee-saved registers
  stack_align: [bytes]           // Stack alignment
  red_zone: [bytes]              // Red zone size
}
```

### 5.2 Binary Encoding of ABI Definitions

The binary encoding of an ABI definition uses specialized opcodes:

```
0x00 EXIT - End ABI definition block
0x01 PARAMS - Parameter registers
0x02 RETS - Return registers
0x03 CALLER - Caller-saved registers
0x04 CALLEE - Callee-saved registers
0x05 SALLIGN - Stack alignment
0x06 RZONE - Red zone size
```

## 6. Processing Units and Register System

COIL v1 supports all types of processing units individually, including CPUs, GPUs, TPUs, and other specialized processors. Each unit is targeted through its unique ISA and register system.

### 6.1 Processing Unit Selection

To target a specific processing unit:
1. Set the processor type (CPU, GPU, etc.) using the PROC instruction
2. Set the architecture (x86, ARM, etc.) using the ARCH instruction
3. Set the mode if needed (32-bit, 64-bit, etc.) using the MODE instruction

The architecture directive must always be preceded by the processor directive, as an architecture is a subset of a processing unit. The architecture argument will have different meaning depending on which processing unit has been selected.

### 6.2 Register Systems

Each processing unit and architecture has its own register system. When targeting specific hardware, the appropriate register set becomes available through the TYPE_R* types.

#### 6.2.1 CPU Architectures
- x86x86
- ARM
- RISCV

#### 6.2.2 GPU Architectures
- Support for standard GPU register models
- Vector and scalar register types
- Local/shared memory addressing

#### 6.2.3 Specialized Processors
- TPU register models
- DSP register models
- Other specialized accelerator registers

### 6.3 Register Management Principles

Register management in COIL is architecture-dependent, as different architectures have fundamentally different register systems. The following principles apply:

1. Direct register access should be minimized in favor of using variables when possible
2. When direct register access is required, the appropriate register types (TYPE_RGP, TYPE_RFP, etc.) should be used
3. For system calls and other operations that require specific registers, an ABI should be defined and used
4. The COIL processor will handle register allocation and optimization when possible
5. For bare metal or system-level programming, direct register access may be necessary

### 6.4 Single-Device Limitation

COIL v1 can target any single processing unit, but does not support switching between multiple devices within a single execution context. Each COIL program targets exactly one processing device at a time.

## 7. Object Format

### 7.1 COIL Object (.coil)

The primary input format containing:
- Symbol tables
- String tables
- Type information
- Instruction sequences
- Metadata

The COIL object is a complex object format containing multiple sections needed to ensure the easiest end user experience. It contains multiple sections similar to native object formats like symbol tables, string tables, etc.

### 7.2 COIL Output Object (.coilo)

The processed output format containing:
- Architecture-specific binary code
- Linking information
- Cross-architecture metadata
- Optimization data

The COIL Output Object is an even more complex object format than the default. This object format handles native binary code for multiple devices in an easy to link and space-efficient manner. The COIL Output Object is the output of COIL processors who then hand this to COIL compatible linkers.

## 8. Configuration Format

The configuration format specifies target capabilities:

```
[device]
arch = [architecture]
processor = [processor]
features = [feature list]

[memory]
model = [memory model]
alignment = [alignment requirements]

[security]
features = [security features]

[linker]
sections = [section definitions]
```

### 8.1 Device Targets

As of version 1, there is only support for compiling to a host device where the host device can have different targets. There is currently no support for other processing devices like GPU, TPU, QPU, etc. Version 3 of COIL will implement this but will most likely come at the cost of some JIT and operating system support with larger binaries.

A device target separate from another device defines the features for a processing unit with multiple architectures. A more practical use case is mainly designed for ARM32 with ARM64 and x86, x86 protected mode, and x86 long mode. Switching between these is important in bootloaders and bare metal devices.

### 8.2 Sections

The Configuration Format will also have sections besides feature processing:
- Each device having information about security features
- Memory layout and memory model
- Resources (threads, registers, etc.)
- Power specifications
- Linker configuration with a simple linker script format

## 9. Debug Format

Debug Symbols and Debug Information should be able to be applied in a COIL file to be propagated into either the final binary or for debuggers to take a standard COIL file and debug through an interpreted setup.

The debug format provides:
- Line number information
- Symbol name mappings
- Type information for debugging
- Source file references
- Call stack unwinding information

## 10. Implementation Requirements

To qualify as a COIL v1 processor, an implementation must:

1. Support the full core instruction set
2. Implement the complete type system
3. Handle the object format for both input and output
4. Process the configuration format
5. Support at least one target architecture fully

## 11. Version Compatibility

COIL v1 establishes the foundation for future versions. Implementations should:

1. Use version markers in generated files
2. Reject incompatible version constructs
3. Clearly identify any extensions beyond the core specification

Future versions will maintain backward compatibility with valid v1 code:
- COIL v2 will add a standard library
- COIL v3 will add multi-device support

Each version will build upon the previous version without breaking compatibility.