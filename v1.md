# COIL v1 Specification: Instruction Set Architecture

## 1. Introduction

The Computer Oriented Intermediate Language (COIL) version 1 defines a complete Instruction Set Architecture (ISA) capable of targeting any single processing unit. This specification establishes the foundational binary format, instruction set, and type system that enables portable code generation across diverse architectures while maintaining native performance characteristics.

## 2. Binary Encoding

### 2.1 Instruction Format

COIL instructions follow a consistent binary format:

```
[Opcode (8 bits)] [Operand Count (8 bits)] [Operands...]
```

Each operand consists of:
```
[Type (16 bits)] [Type-Specific Data (variable)] [Value (variable)]
```

### 2.2 Opcode Organization

The 8-bit opcode space is organized into functional categories:

```
0x00      - No Operation
0x01-0x0F - Control Flow
0x10-0x2F - Memory Operations
0x30-0x4F - Reserved for Multi-Device Operations (v3)
0x50-0x5F - Bit Manipulation
0x60-0x8F - Arithmetic
0x90-0x9F - Vector/Array Operations
0xA0-0xAF - Type Instructions
0xB0-0xBF - Directive Instructions
0xC0-0xFE - Architecture/Processor-Specific Instructions
0xFF      - COIL Processor-Specific Extensions
```

#### 2.2.1 Reserved Instruction Space

The range 0x30-0x4F is intentionally reserved in COIL v1 for future multi-device operations in COIL v3. This space will later include instructions for:

- Device selection and switching
- Cross-device memory transfers
- Synchronization between devices
- Parallel execution coordination
- Device capability queries
- Queue and workgroup management

Attempting to use opcodes in this range in v1 will result in an invalid instruction error.

## 3. Type System

The type system is encoded in 16 bits, with the first 8 bits representing the main type and the second 8 bits representing type extensions.

### 3.1 Main Types (First 8 bits)

```
// Fixed width signed integers
0x01-0x05 - TYPE_INT8 through TYPE_INT128

// Fixed width unsigned integers
0x10-0x15 - TYPE_UNT8 through TYPE_UNT128
  
// Fixed width floating point
0x20-0x28 - TYPE_FP8e5m2 through TYPE_FP128

// Fixed Width Vectors
0x30-0x32 - TYPE_V128 through TYPE_V512

// Boolean type
0x40      - TYPE_BIT (1-bit boolean)

// COIL Special Types
0x90-0x9C - Register and state types

// Platform Dependent Types
0xA0-0xA6 - Platform-specific size types

// Complex Types
0xB0-0xB2 - Complex number types

// Composite Types
0xD0-0xD3 - Structure, union, array types

// Parameter Types
0xF0-0xFE - TYPE_PARAM0 through TYPE_PARAM5

// Void Type
0xFF      - TYPE_VOID
```

### 3.2 Type Extensions (Second 8 bits)

```
0x01 - TYPEEXT_CONST    - Constant value (read-only)
0x02 - TYPEEXT_VOLATILE - Volatile access (not optimizable)
0x10 - TYPEEXT_VOID     - No Value
0x20 - TYPEEXT_IMM      - Immediate value
0x40 - TYPEEXT_VAR      - Variable ID
0x80 - TYPEEXT_SYM      - Symbol ID
```

## 4. Core Instruction Set

### 4.1 Control Flow (0x01-0x0F)

Core instructions for program flow control:

- 0x01 SYM - Define a symbol
- 0x02 BR - Branch to a program address
- 0x03 CALL - Enter procedure
- 0x04 RET - Return from procedure
- 0x05 CMP - Compare values and set flags
- 0x06 TEST - Bitwise AND and set flags

### 4.2 Memory Operations (0x10-0x2F)

Instructions for memory access and management:

- 0x10 MOV - Move data between locations
- 0x11 PUSH - Push value onto stack
- 0x12 POP - Pop value from stack
- 0x13 LEA - Load effective address
- 0x14-0x15 SCOPE - Scope entry/exit
- 0x16 VAR - Variable declaration
- 0x17-0x19 Memory block operations
- 0x1A-0x1B Atomic operations
- 0x2E-0x2F Memory pinning for DMA

### 4.3 Bit Manipulation (0x50-0x5F)

Instructions for binary operations:

- 0x50-0x53 Basic bitwise operations (AND, OR, XOR, NOT)
- 0x54-0x56 Shift operations (SHL, SHR, SAR)
- 0x57-0x58 Rotate operations (ROL, ROR)
- 0x59-0x5A Bit counting and swap operations

### 4.4 Arithmetic (0x60-0x8F)

Mathematical operations:

- 0x60-0x64 Basic arithmetic (ADD, SUB, MUL, DIV, MOD)
- 0x65-0x68 Value modification (INC, DEC, NEG, ABS)
- 0x69-0x6A Advanced math (SQRT, FMA)
- 0x7B-0x7C Comparison operations (MIN, MAX)

### 4.5 Vector/Array Operations (0x90-0x9F)

Operations on multiple values:

- 0x95 VDOT - Vector dot product

### 4.6 Type Instructions (0xA0-0xAF)

Type manipulation:

- 0xA0-0xA2 Type information (TYPEOF, SIZEOF, ALIGNOF)
- 0xA3-0xA4 Type conversion (CONVERT, CAST)
- 0xA5 Structure definition
- 0xA6-0xA7 Field/element access (GET, INDEX)

### 4.7 Directive Instructions (0xB0-0xBF)

Code generation directives:

- 0xB0-0xB2 Target specification (ARCH, PROC, MODE)
- 0xB3-0xB5 Output control (ALIGN, SECTION, DATA)
- 0xB6-0xB9 Conditional compilation (IF, ELIF, ELSE, ENDIF)
- 0xBA ABI definition

## 5. Application Binary Interface (ABI)

COIL supports custom calling conventions through ABI definitions:

```
abi definition {
  param_regs: [register list]    // Parameter registers
  return_regs: [register list]   // Return value registers
  caller_saved: [register list]  // Caller-saved registers
  callee_saved: [register list]  // Callee-saved registers
  stack_align: [bytes]           // Stack alignment
  red_zone: [bytes]              // Red zone size
}
```

The binary encoding of an ABI definition uses specialized opcodes:
- 0x00 EXIT - End ABI definition block
- 0x01 PARAMS - Parameter registers
- 0x02 RETS - Return registers
- 0x03 CALLER - Caller-saved registers
- 0x04 CALLEE - Callee-saved registers
- 0x05 SALLIGN - Stack alignment
- 0x06 RZONE - Red zone size

## 6. Processing Units and Register System

COIL v1 supports all types of processing units individually, including CPUs, GPUs, TPUs, and other specialized processors. Each unit is targeted through its unique ISA and register system.

### 6.1 Processing Unit Selection

To target a specific processing unit:
1. Set the processor type (CPU, GPU, etc.) using the PROC instruction
2. Set the architecture (x86-64, ARM-64, etc.) using the ARCH instruction
3. Set the mode if needed (32-bit, 64-bit, etc.) using the MODE instruction

### 6.2 Register Systems

Each processing unit and architecture has its own register system. When targeting specific hardware, the appropriate register set becomes available through the TYPE_R* types.

#### 6.2.1 CPU Architectures
- x86-16, x86-32, x86-64
- ARM-32, ARM-64
- RISCV-32, RISCV-64

#### 6.2.2 GPU Architectures
- Support for standard GPU register models
- Vector and scalar register types
- Local/shared memory addressing

#### 6.2.3 Specialized Processors
- TPU register models
- DSP register models
- Other specialized accelerator registers

### 6.3 Single-Device Limitation

COIL v1 can target any single processing unit, but does not support switching between multiple devices within a single execution context. Each COIL program targets exactly one processing device at a time.

## 7. Object Format

### 7.1 COIL Object (.coil)

The primary input format containing:
- Symbol tables
- String tables
- Type information
- Instruction sequences
- Metadata

### 7.2 COIL Output Object (.coilo)

The processed output format containing:
- Architecture-specific binary code
- Linking information
- Cross-architecture metadata
- Optimization data

## 8. Configuration Format

The configuration format specifies target capabilities:

```
[device]
arch = [architecture]
processor = [processor]
features = [feature list]

[memory]
model = [memory model]
alignment = [alignment requirements]

[security]
features = [security features]

[linker]
sections = [section definitions]
```

## 9. Implementation Requirements

To qualify as a COIL v1 processor, an implementation must:

1. Support the full core instruction set
2. Implement the complete type system
3. Handle the object format for both input and output
4. Process the configuration format
5. Support at least one target architecture fully

## 10. Version Compatibility

COIL v1 establishes the foundation for future versions. Implementations should:

1. Use version markers in generated files
2. Reject incompatible version constructs
3. Clearly identify any extensions beyond the core specification

Future versions will maintain backward compatibility with valid v1 code.