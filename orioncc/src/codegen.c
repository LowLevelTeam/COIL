#include "codegen.h"

#define SYMBOL_TABLE_SIZE 256

// Hash function for symbol table
static size_t hash_string(const char *str) {
  size_t hash = 5381;
  int c;
  while ((c = *str++)) {
    hash = ((hash << 5) + hash) + c;
  }
  return hash % SYMBOL_TABLE_SIZE;
}

// Symbol table management
SymbolTable *symbol_table_create(void) {
  SymbolTable *table = safe_malloc(sizeof(SymbolTable));
  table->buckets = safe_malloc(sizeof(Symbol*) * SYMBOL_TABLE_SIZE);
  table->bucket_count = SYMBOL_TABLE_SIZE;
  table->current_scope = 0;
  
  // Initialize all buckets to NULL
  for (size_t i = 0; i < SYMBOL_TABLE_SIZE; i++) {
    table->buckets[i] = NULL;
  }
  
  return table;
}

void symbol_table_destroy(SymbolTable *table) {
  if (!table) return;
  
  for (size_t i = 0; i < table->bucket_count; i++) {
    Symbol *current = table->buckets[i];
    while (current) {
      Symbol *next = current->next;
      free(current->name);
      free(current);
      current = next;
    }
  }
  
  free(table->buckets);
  free(table);
}

OrionError symbol_table_define(SymbolTable *table, const char *name, TypeInfo type, bool is_param, int param_index) {
  if (!table || !name) return ORION_ERROR_INVALID_ARGUMENT;
  
  size_t hash = hash_string(name);
  Symbol *symbol = safe_malloc(sizeof(Symbol));
  symbol->name = string_duplicate(name);
  symbol->type = type;
  symbol->scope_level = table->current_scope;
  symbol->is_parameter = is_param;
  symbol->parameter_index = param_index;
  symbol->next = table->buckets[hash];
  table->buckets[hash] = symbol;
  
  return ORION_SUCCESS;
}

Symbol *symbol_table_lookup(SymbolTable *table, const char *name) {
  if (!table || !name) return NULL;
  
  size_t hash = hash_string(name);
  Symbol *current = table->buckets[hash];
  
  while (current) {
    if (strcmp(current->name, name) == 0) {
      return current;
    }
    current = current->next;
  }
  
  return NULL;
}

void symbol_table_enter_scope(SymbolTable *table) {
  if (table) {
    table->current_scope++;
  }
}

void symbol_table_exit_scope(SymbolTable *table) {
  if (!table) return;
  
  // Remove symbols from current scope
  for (size_t i = 0; i < table->bucket_count; i++) {
    Symbol **current = &table->buckets[i];
    while (*current) {
      if ((*current)->scope_level == table->current_scope) {
        Symbol *to_remove = *current;
        *current = (*current)->next;
        free(to_remove->name);
        free(to_remove);
      } else {
        current = &(*current)->next;
      }
    }
  }
  
  if (table->current_scope > 0) {
    table->current_scope--;
  }
}

// Code generator API
OrionError codegen_init(CodeGen *gen, FILE *output, CompilerOptions *options) {
  if (!gen || !output) return ORION_ERROR_INVALID_ARGUMENT;
  
  gen->output = output;
  gen->symbols = symbol_table_create();
  gen->options = options;
  gen->label_counter = 0;
  gen->temp_counter = 0;
  gen->current_function = NULL;
  gen->in_function = false;
  gen->current_break_label = NULL;
  gen->current_continue_label = NULL;
  gen->had_error = false;
  gen->error_count = 0;
  
  return ORION_SUCCESS;
}

void codegen_cleanup(CodeGen *gen) {
  if (!gen) return;
  
  symbol_table_destroy(gen->symbols);
  gen->symbols = NULL;
}

OrionError codegen_generate_program(CodeGen *gen, ASTNode *program) {
  if (!gen || !program || program->type != AST_PROGRAM) {
    return ORION_ERROR_INVALID_ARGUMENT;
  }
  
  // Generate file header
  codegen_emit_comment(gen, "Generated by Orion C Compiler");
  codegen_emit_comment(gen, "ORION++ ISA Assembly Output");
  fprintf(gen->output, "\n");
  
  // Generate text section
  codegen_emit_section(gen, "EXEC", ".text");
  fprintf(gen->output, "\n");
  
  // Generate all functions
  for (size_t i = 0; i < program->program.function_count; i++) {
    OrionError error = codegen_function(gen, program->program.functions[i]);
    if (error != ORION_SUCCESS) {
      return error;
    }
    fprintf(gen->output, "\n");
  }
  
  return gen->had_error ? ORION_ERROR_CODEGEN : ORION_SUCCESS;
}

// Helper functions
const char *codegen_get_temp_var(CodeGen *gen) {
  static char temp_name[32];
  snprintf(temp_name, sizeof(temp_name), "temp_%d", gen->temp_counter++);
  return temp_name;
}

const char *codegen_get_label(CodeGen *gen) {
  static char label_name[32];
  snprintf(label_name, sizeof(label_name), ".L%d", gen->label_counter++);
  return label_name;
}

void codegen_emit_comment(CodeGen *gen, const char *comment) {
  fprintf(gen->output, "// %s\n", comment);
}

void codegen_emit_label(CodeGen *gen, const char *label) {
  fprintf(gen->output, "    obj.label %s:\n", label);
}

void codegen_emit_instruction(CodeGen *gen, const char *instr, const char *operands) {
  if (operands && strlen(operands) > 0) {
    fprintf(gen->output, "    %s %s\n", instr, operands);
  } else {
    fprintf(gen->output, "    %s\n", instr);
  }
}

// Orion++ ISA instruction emission
void codegen_emit_let(CodeGen *gen, const char *var, const char *value) {
  fprintf(gen->output, "    isa.let %s, %s\n", var, value);
}

void codegen_emit_const(CodeGen *gen, const char *var, int value) {
  fprintf(gen->output, "    isa.const %s, %d\n", var, value);
}

void codegen_emit_mov(CodeGen *gen, const char *dest, const char *src) {
  fprintf(gen->output, "    isa.mov %s, %s\n", dest, src);
}

void codegen_emit_add(CodeGen *gen, const char *dest, const char *src1, const char *src2) {
  fprintf(gen->output, "    isa.add %s, %s, %s\n", dest, src1, src2);
}

void codegen_emit_sub(CodeGen *gen, const char *dest, const char *src1, const char *src2) {
  fprintf(gen->output, "    isa.sub %s, %s, %s\n", dest, src1, src2);
}

void codegen_emit_mul(CodeGen *gen, const char *dest, const char *src1, const char *src2) {
  fprintf(gen->output, "    isa.mul %s, %s, %s\n", dest, src1, src2);
}

void codegen_emit_div(CodeGen *gen, const char *dest, const char *src1, const char *src2) {
  fprintf(gen->output, "    isa.div %s, %s, %s\n", dest, src1, src2);
}

void codegen_emit_mod(CodeGen *gen, const char *dest, const char *src1, const char *src2) {
  fprintf(gen->output, "    isa.mod %s, %s, %s\n", dest, src1, src2);
}

void codegen_emit_neg(CodeGen *gen, const char *dest, const char *src) {
  fprintf(gen->output, "    isa.neg %s, %s\n", dest, src);
}

void codegen_emit_and(CodeGen *gen, const char *dest, const char *src1, const char *src2) {
  fprintf(gen->output, "    isa.and %s, %s, %s\n", dest, src1, src2);
}

void codegen_emit_or(CodeGen *gen, const char *dest, const char *src1, const char *src2) {
  fprintf(gen->output, "    isa.or %s, %s, %s\n", dest, src1, src2);
}

void codegen_emit_xor(CodeGen *gen, const char *dest, const char *src1, const char *src2) {
  fprintf(gen->output, "    isa.xor %s, %s, %s\n", dest, src1, src2);
}

void codegen_emit_not(CodeGen *gen, const char *dest, const char *src) {
  fprintf(gen->output, "    isa.not %s, %s\n", dest, src);
}

void codegen_emit_shl(CodeGen *gen, const char *dest, const char *src, const char *count) {
  fprintf(gen->output, "    isa.shl %s, %s, %s\n", dest, src, count);
}

void codegen_emit_shr(CodeGen *gen, const char *dest, const char *src, const char *count) {
  fprintf(gen->output, "    isa.shr %s, %s, %s\n", dest, src, count);
}

// Control flow instructions
void codegen_emit_jmp(CodeGen *gen, const char *label) {
  fprintf(gen->output, "    isa.jmp %s\n", label);
}

void codegen_emit_call(CodeGen *gen, const char *function) {
  fprintf(gen->output, "    isa.call %s\n", function);
}

void codegen_emit_ret(CodeGen *gen) {
  fprintf(gen->output, "    isa.RET\n");
}

void codegen_emit_beq(CodeGen *gen, const char *src1, const char *src2, const char *label) {
  fprintf(gen->output, "    isa.beq %s, %s, %s\n", src1, src2, label);
}

void codegen_emit_bne(CodeGen *gen, const char *src1, const char *src2, const char *label) {
  fprintf(gen->output, "    isa.bne %s, %s, %s\n", src1, src2, label);
}

void codegen_emit_blt(CodeGen *gen, const char *src1, const char *src2, const char *label) {
  fprintf(gen->output, "    isa.blt %s, %s, %s\n", src1, src2, label);
}

void codegen_emit_ble(CodeGen *gen, const char *src1, const char *src2, const char *label) {
  fprintf(gen->output, "    isa.ble %s, %s, %s\n", src1, src2, label);
}

void codegen_emit_bgt(CodeGen *gen, const char *src1, const char *src2, const char *label) {
  fprintf(gen->output, "    isa.bgt %s, %s, %s\n", src1, src2, label);
}

void codegen_emit_bge(CodeGen *gen, const char *src1, const char *src2, const char *label) {
  fprintf(gen->output, "    isa.bge %s, %s, %s\n", src1, src2, label);
}

void codegen_emit_beqz(CodeGen *gen, const char *src, const char *label) {
  fprintf(gen->output, "    isa.beqz %s, %s\n", src, label);
}

void codegen_emit_bnez(CodeGen *gen, const char *src, const char *label) {
  fprintf(gen->output, "    isa.bnez %s, %s\n", src, label);
}

// Object and symbol management
void codegen_emit_section(CodeGen *gen, const char *type, const char *name) {
  fprintf(gen->output, "obj.section [%s] %s\n", type, name);
}

void codegen_emit_symbol(CodeGen *gen, const char *visibility, const char *type, const char *name) {
  fprintf(gen->output, "obj.sym[%s,%s] %s:\n", visibility, type, name);
}

void codegen_emit_hint_abi(CodeGen *gen, const char *abi) {
  fprintf(gen->output, "  .hint-abi(%s)\n", abi);
}

void codegen_emit_hint_args(CodeGen *gen, const char *args) {
  fprintf(gen->output, "  .hint-args(%s)\n", args);
}

void codegen_emit_hint_rets(CodeGen *gen, const char *rets) {
  fprintf(gen->output, "  .hint-rets(%s)\n", rets);
}

void codegen_emit_hint_endfunc(CodeGen *gen) {
  fprintf(gen->output, ".hint-endfunc()\n");
}

// ABI support
void codegen_emit_abi_callee_enter(CodeGen *gen) {
  fprintf(gen->output, "  abi.callee.enter\n");
}

void codegen_emit_abi_callee_leave(CodeGen *gen) {
  fprintf(gen->output, "  abi.callee.leave\n");
}

void codegen_emit_abi_callee_getarg(CodeGen *gen, const char *dest, int index) {
  fprintf(gen->output, "    isa.let %s, abi.callee.getarg.%d\n", dest, index);
}

void codegen_emit_abi_callee_setret(CodeGen *gen, const char *src, int index) {
  fprintf(gen->output, "    abi.callee.setret.%d %s\n", index, src);
}

void codegen_emit_abi_caller_setup(CodeGen *gen) {
  fprintf(gen->output, "    abi.caller.setup\n");
}

void codegen_emit_abi_caller_cleanup(CodeGen *gen) {
  fprintf(gen->output, "    abi.caller.cleanup\n");
}

void codegen_emit_abi_caller_setarg(CodeGen *gen, const char *src, int index) {
  fprintf(gen->output, "    abi.caller.setarg.%d %s\n", index, src);
}

void codegen_emit_abi_caller_getret(CodeGen *gen, const char *dest, int index) {
  fprintf(gen->output, "    isa.let %s, abi.caller.getret.%d\n", dest, index);
}

// Scope management
void codegen_emit_enter(CodeGen *gen) {
  fprintf(gen->output, "  isa.enter // {\n");
}

void codegen_emit_leave(CodeGen *gen) {
  fprintf(gen->output, "  isa.leave // }\n");
}

void codegen_error(CodeGen *gen, const char *message, SourcePosition pos) {
  if (!gen) return;
  
  gen->had_error = true;
  gen->error_count++;
  
  if (pos.filename) {
    fprintf(stderr, "Codegen error in %s at line %d, column %d: %s\n", 
            pos.filename, pos.line, pos.column, message);
  } else {
    fprintf(stderr, "Codegen error at line %d, column %d: %s\n", 
            pos.line, pos.column, message);
  }
}

// Main code generation functions
OrionError codegen_function(CodeGen *gen, ASTNode *func) {
  if (!gen || !func || func->type != AST_FUNCTION) {
    return ORION_ERROR_INVALID_ARGUMENT;
  }
  
  if (gen->options && gen->options->debug_mode) {
    debug_print("Generating code for function '%s'", func->function.name);
  }
  
  gen->current_function = func->function.name;
  gen->in_function = true;
  
  // Enter function scope
  symbol_table_enter_scope(gen->symbols);
  
  if (gen->options && gen->options->debug_mode) {
    debug_print("Entered function scope, current scope level: %d", gen->symbols->current_scope);
  }
  
  // Emit function symbol
  codegen_emit_symbol(gen, "global", "func", func->function.name);
  codegen_emit_hint_abi(gen, "c");
  
  // Generate parameter hints
  if (func->function.param_count == 0) {
    codegen_emit_hint_args(gen, "null");
  } else {
    fprintf(gen->output, "  .hint-args(");
    for (size_t i = 0; i < func->function.param_count; i++) {
      if (i > 0) fprintf(gen->output, ", ");
      fprintf(gen->output, "i32");
    }
    fprintf(gen->output, ")\n");
  }
  
  // Return type hint
  if (func->function.return_type.base_type == TYPE_VOID) {
    codegen_emit_hint_rets(gen, "void");
  } else {
    codegen_emit_hint_rets(gen, "i32");
  }
  
  fprintf(gen->output, "\n");
  
  // ABI prologue
  codegen_emit_abi_callee_enter(gen);
  fprintf(gen->output, "\n");
  codegen_emit_enter(gen);
  
  // Define parameters as local variables
  for (size_t i = 0; i < func->function.param_count; i++) {
    ASTNode *param = func->function.parameters[i];
    symbol_table_define(gen->symbols, param->parameter.name, 
                       param->parameter.param_type, true, (int)i);
    codegen_emit_abi_callee_getarg(gen, param->parameter.name, (int)i);
    
    if (gen->options && gen->options->debug_mode) {
      debug_print("Defined parameter '%s' at index %d", param->parameter.name, (int)i);
    }
  }
  
  // Generate function body
  OrionError error = codegen_statement(gen, func->function.body);
  
  // ABI epilogue
  codegen_emit_leave(gen);
  fprintf(gen->output, "\n");
  codegen_emit_abi_callee_leave(gen);
  codegen_emit_ret(gen);
  fprintf(gen->output, "\n");
  codegen_emit_hint_endfunc(gen);
  
  // Exit function scope
  symbol_table_exit_scope(gen->symbols);
  
  if (gen->options && gen->options->debug_mode) {
    debug_print("Exited function scope, current scope level: %d", gen->symbols->current_scope);
  }
  
  gen->in_function = false;
  gen->current_function = NULL;
  
  return error;
}

OrionError codegen_statement(CodeGen *gen, ASTNode *stmt) {
  if (!gen || !stmt) return ORION_ERROR_INVALID_ARGUMENT;
  
  switch (stmt->type) {
    case AST_COMPOUND_STMT:
      return codegen_compound_stmt(gen, stmt);
    case AST_IF_STMT:
      return codegen_if_stmt(gen, stmt);
    case AST_WHILE_STMT:
      return codegen_while_stmt(gen, stmt);
    case AST_RETURN_STMT:
      return codegen_return_stmt(gen, stmt);
    case AST_VAR_DECL:
      return codegen_var_decl(gen, stmt);
    case AST_EXPRESSION_STMT:
      return codegen_expression_stmt(gen, stmt);
    default:
      codegen_error(gen, "Unsupported statement type", stmt->pos);
      return ORION_ERROR_CODEGEN;
  }
}

OrionError codegen_compound_stmt(CodeGen *gen, ASTNode *stmt) {
  // Don't create a new scope if we're already in a function - 
  // the function scope is sufficient for function-level variables
  bool should_manage_scope = !gen->in_function;
  
  if (should_manage_scope) {
    symbol_table_enter_scope(gen->symbols);
  }
  
  for (size_t i = 0; i < stmt->compound.stmt_count; i++) {
    OrionError error = codegen_statement(gen, stmt->compound.statements[i]);
    if (error != ORION_SUCCESS) {
      if (should_manage_scope) {
        symbol_table_exit_scope(gen->symbols);
      }
      return error;
    }
  }
  
  if (should_manage_scope) {
    symbol_table_exit_scope(gen->symbols);
  }
  
  return ORION_SUCCESS;
}

OrionError codegen_if_stmt(CodeGen *gen, ASTNode *stmt) {
  const char *else_label = codegen_get_label(gen);
  const char *end_label = codegen_get_label(gen);
  
  // Generate condition
  const char *cond_var = codegen_get_temp_var(gen);
  OrionError error = codegen_expression(gen, stmt->if_stmt.condition, cond_var);
  if (error != ORION_SUCCESS) return error;
  
  // Branch to else if condition is false (0)
  codegen_emit_beqz(gen, cond_var, stmt->if_stmt.else_stmt ? else_label : end_label);
  
  // Generate then statement
  error = codegen_statement(gen, stmt->if_stmt.then_stmt);
  if (error != ORION_SUCCESS) return error;
  
  if (stmt->if_stmt.else_stmt) {
    codegen_emit_jmp(gen, end_label);
    codegen_emit_label(gen, else_label);
    error = codegen_statement(gen, stmt->if_stmt.else_stmt);
    if (error != ORION_SUCCESS) return error;
  }
  
  codegen_emit_label(gen, end_label);
  return ORION_SUCCESS;
}

OrionError codegen_while_stmt(CodeGen *gen, ASTNode *stmt) {
  const char *start_label = codegen_get_label(gen);
  const char *end_label = codegen_get_label(gen);
  
  // Save break/continue labels
  const char *old_break = gen->current_break_label;
  const char *old_continue = gen->current_continue_label;
  gen->current_break_label = end_label;
  gen->current_continue_label = start_label;
  
  codegen_emit_label(gen, start_label);
  
  // Generate condition
  const char *cond_var = codegen_get_temp_var(gen);
  OrionError error = codegen_expression(gen, stmt->while_stmt.condition, cond_var);
  if (error != ORION_SUCCESS) goto cleanup;
  
  // Branch to end if condition is false
  codegen_emit_beqz(gen, cond_var, end_label);
  
  // Generate body
  error = codegen_statement(gen, stmt->while_stmt.body);
  if (error != ORION_SUCCESS) goto cleanup;
  
  // Jump back to start
  codegen_emit_jmp(gen, start_label);
  codegen_emit_label(gen, end_label);
  
cleanup:
  // Restore break/continue labels
  gen->current_break_label = old_break;
  gen->current_continue_label = old_continue;
  
  return error;
}

OrionError codegen_return_stmt(CodeGen *gen, ASTNode *stmt) {
  if (stmt->return_stmt.expression) {
    const char *ret_var = codegen_get_temp_var(gen);
    OrionError error = codegen_expression(gen, stmt->return_stmt.expression, ret_var);
    if (error != ORION_SUCCESS) return error;
    codegen_emit_abi_callee_setret(gen, ret_var, 0);
  }
  return ORION_SUCCESS;
}

OrionError codegen_var_decl(CodeGen *gen, ASTNode *stmt) {
  if (gen->options && gen->options->debug_mode) {
    debug_print("Declaring variable '%s'", stmt->var_decl.name);
  }
  
  // Add to symbol table first
  OrionError error = symbol_table_define(gen->symbols, stmt->var_decl.name, 
                                        stmt->var_decl.var_type, false, -1);
  if (error != ORION_SUCCESS) {
    codegen_error(gen, "Failed to define variable in symbol table", stmt->pos);
    return error;
  }
  
  if (stmt->var_decl.initializer) {
    const char *temp_var = codegen_get_temp_var(gen);
    error = codegen_expression(gen, stmt->var_decl.initializer, temp_var);
    if (error != ORION_SUCCESS) return error;
    codegen_emit_let(gen, stmt->var_decl.name, temp_var);
  } else {
    // For uninitialized variables, create with value 0
    const char *zero_temp = codegen_get_temp_var(gen);
    codegen_emit_const(gen, zero_temp, 0);
    codegen_emit_let(gen, stmt->var_decl.name, zero_temp);
  }
  
  if (gen->options && gen->options->debug_mode) {
    debug_print("Variable '%s' declared and initialized", stmt->var_decl.name);
  }
  
  return ORION_SUCCESS;
}

OrionError codegen_expression_stmt(CodeGen *gen, ASTNode *stmt) {
  if (stmt->expr_stmt.expression) {
    const char *temp_var = codegen_get_temp_var(gen);
    return codegen_expression(gen, stmt->expr_stmt.expression, temp_var);
  }
  return ORION_SUCCESS;
}

OrionError codegen_expression(CodeGen *gen, ASTNode *expr, const char *dest_var) {
  if (!gen || !expr || !dest_var) return ORION_ERROR_INVALID_ARGUMENT;
  
  switch (expr->type) {
    case AST_INTEGER_LITERAL:
      return codegen_integer_literal(gen, expr, dest_var);
    case AST_VAR_REF:
      return codegen_var_ref(gen, expr, dest_var);
    case AST_BINARY_EXPR:
      return codegen_binary_expr(gen, expr, dest_var);
    case AST_UNARY_EXPR:
      return codegen_unary_expr(gen, expr, dest_var);
    case AST_CALL_EXPR:
      return codegen_call_expr(gen, expr, dest_var);
    case AST_ASSIGN_EXPR:
      return codegen_assign_expr(gen, expr, dest_var);
    default:
      codegen_error(gen, "Unsupported expression type", expr->pos);
      return ORION_ERROR_CODEGEN;
  }
}

OrionError codegen_integer_literal(CodeGen *gen, ASTNode *expr, const char *dest_var) {
  codegen_emit_const(gen, dest_var, expr->integer.value);
  return ORION_SUCCESS;
}

OrionError codegen_var_ref(CodeGen *gen, ASTNode *expr, const char *dest_var) {
  if (gen->options && gen->options->debug_mode) {
    debug_print("Looking up variable '%s'", expr->var_ref.name);
  }
  
  Symbol *symbol = symbol_table_lookup(gen->symbols, expr->var_ref.name);
  if (!symbol) {
    char error_msg[256];
    snprintf(error_msg, sizeof(error_msg), "Undefined variable '%s'", expr->var_ref.name);
    codegen_error(gen, error_msg, expr->pos);
    return ORION_ERROR_CODEGEN;
  }
  
  if (gen->options && gen->options->debug_mode) {
    debug_print("Found variable '%s' in scope %d", expr->var_ref.name, symbol->scope_level);
  }
  
  codegen_emit_mov(gen, dest_var, expr->var_ref.name);
  return ORION_SUCCESS;
}

OrionError codegen_binary_expr(CodeGen *gen, ASTNode *expr, const char *dest_var) {
  const char *left_var = codegen_get_temp_var(gen);
  const char *right_var = codegen_get_temp_var(gen);
  
  OrionError error = codegen_expression(gen, expr->binary.left, left_var);
  if (error != ORION_SUCCESS) return error;
  
  error = codegen_expression(gen, expr->binary.right, right_var);
  if (error != ORION_SUCCESS) return error;
  
  switch (expr->binary.operator) {
    case TOK_PLUS:
      codegen_emit_add(gen, dest_var, left_var, right_var);
      break;
    case TOK_MINUS:
      codegen_emit_sub(gen, dest_var, left_var, right_var);
      break;
    case TOK_MULTIPLY:
      codegen_emit_mul(gen, dest_var, left_var, right_var);
      break;
    case TOK_DIVIDE:
      codegen_emit_div(gen, dest_var, left_var, right_var);
      break;
    case TOK_MODULO:
      codegen_emit_mod(gen, dest_var, left_var, right_var);
      break;
    case TOK_AND:
      codegen_emit_and(gen, dest_var, left_var, right_var);
      break;
    case TOK_OR:
      codegen_emit_or(gen, dest_var, left_var, right_var);
      break;
    case TOK_XOR:
      codegen_emit_xor(gen, dest_var, left_var, right_var);
      break;
    case TOK_LSHIFT:
      codegen_emit_shl(gen, dest_var, left_var, right_var);
      break;
    case TOK_RSHIFT:
      codegen_emit_shr(gen, dest_var, left_var, right_var);
      break;
      
    // Comparison operations
    case TOK_LT: {
      const char *true_label = codegen_get_label(gen);
      const char *end_label = codegen_get_label(gen);
      
      codegen_emit_blt(gen, left_var, right_var, true_label);
      codegen_emit_const(gen, dest_var, 0);
      codegen_emit_jmp(gen, end_label);
      codegen_emit_label(gen, true_label);
      codegen_emit_const(gen, dest_var, 1);
      codegen_emit_label(gen, end_label);
      break;
    }
    case TOK_LE: {
      const char *true_label = codegen_get_label(gen);
      const char *end_label = codegen_get_label(gen);
      
      codegen_emit_ble(gen, left_var, right_var, true_label);
      codegen_emit_const(gen, dest_var, 0);
      codegen_emit_jmp(gen, end_label);
      codegen_emit_label(gen, true_label);
      codegen_emit_const(gen, dest_var, 1);
      codegen_emit_label(gen, end_label);
      break;
    }
    case TOK_GT: {
      const char *true_label = codegen_get_label(gen);
      const char *end_label = codegen_get_label(gen);
      
      codegen_emit_bgt(gen, left_var, right_var, true_label);
      codegen_emit_const(gen, dest_var, 0);
      codegen_emit_jmp(gen, end_label);
      codegen_emit_label(gen, true_label);
      codegen_emit_const(gen, dest_var, 1);
      codegen_emit_label(gen, end_label);
      break;
    }
    case TOK_GE: {
      const char *true_label = codegen_get_label(gen);
      const char *end_label = codegen_get_label(gen);
      
      codegen_emit_bge(gen, left_var, right_var, true_label);
      codegen_emit_const(gen, dest_var, 0);
      codegen_emit_jmp(gen, end_label);
      codegen_emit_label(gen, true_label);
      codegen_emit_const(gen, dest_var, 1);
      codegen_emit_label(gen, end_label);
      break;
    }
    case TOK_EQ: {
      const char *true_label = codegen_get_label(gen);
      const char *end_label = codegen_get_label(gen);
      
      codegen_emit_beq(gen, left_var, right_var, true_label);
      codegen_emit_const(gen, dest_var, 0);
      codegen_emit_jmp(gen, end_label);
      codegen_emit_label(gen, true_label);
      codegen_emit_const(gen, dest_var, 1);
      codegen_emit_label(gen, end_label);
      break;
    }
    case TOK_NE: {
      const char *true_label = codegen_get_label(gen);
      const char *end_label = codegen_get_label(gen);
      
      codegen_emit_bne(gen, left_var, right_var, true_label);
      codegen_emit_const(gen, dest_var, 0);
      codegen_emit_jmp(gen, end_label);
      codegen_emit_label(gen, true_label);
      codegen_emit_const(gen, dest_var, 1);
      codegen_emit_label(gen, end_label);
      break;
    }
    
    default:
      codegen_error(gen, "Unsupported binary operator", expr->pos);
      return ORION_ERROR_CODEGEN;
  }
  
  return ORION_SUCCESS;
}

OrionError codegen_unary_expr(CodeGen *gen, ASTNode *expr, const char *dest_var) {
  const char *operand_var = codegen_get_temp_var(gen);
  
  OrionError error = codegen_expression(gen, expr->unary.operand, operand_var);
  if (error != ORION_SUCCESS) return error;
  
  switch (expr->unary.operator) {
    case TOK_MINUS:
      codegen_emit_neg(gen, dest_var, operand_var);
      break;
    case TOK_NOT:
      codegen_emit_not(gen, dest_var, operand_var);
      break;
    default:
      codegen_error(gen, "Unsupported unary operator", expr->pos);
      return ORION_ERROR_CODEGEN;
  }
  
  return ORION_SUCCESS;
}

OrionError codegen_call_expr(CodeGen *gen, ASTNode *expr, const char *dest_var) {
  codegen_emit_abi_caller_setup(gen);
  
  // Set up arguments
  for (size_t i = 0; i < expr->call.arg_count; i++) {
    const char *arg_var = codegen_get_temp_var(gen);
    OrionError error = codegen_expression(gen, expr->call.arguments[i], arg_var);
    if (error != ORION_SUCCESS) return error;
    codegen_emit_abi_caller_setarg(gen, arg_var, (int)i);
  }
  
  // Make the call
  codegen_emit_call(gen, expr->call.name);
  
  // Get return value
  codegen_emit_abi_caller_getret(gen, dest_var, 0);
  codegen_emit_abi_caller_cleanup(gen);
  
  return ORION_SUCCESS;
}

OrionError codegen_assign_expr(CodeGen *gen, ASTNode *expr, const char *dest_var) {
  // Generate rvalue first
  const char *rvalue_var = codegen_get_temp_var(gen);
  OrionError error = codegen_expression(gen, expr->assign.rvalue, rvalue_var);
  if (error != ORION_SUCCESS) return error;
  
  // Handle assignment to lvalue
  if (expr->assign.lvalue->type == AST_VAR_REF) {
    Symbol *symbol = symbol_table_lookup(gen->symbols, expr->assign.lvalue->var_ref.name);
    if (!symbol) {
      codegen_error(gen, "Undefined variable in assignment", expr->pos);
      return ORION_ERROR_CODEGEN;
    }
    
    if (expr->assign.assign_op == TOK_ASSIGN) {
      codegen_emit_mov(gen, expr->assign.lvalue->var_ref.name, rvalue_var);
    } else {
      // Handle compound assignment (+=, -=, etc.)
      const char *old_value = codegen_get_temp_var(gen);
      codegen_emit_mov(gen, old_value, expr->assign.lvalue->var_ref.name);
      
      switch (expr->assign.assign_op) {
        case TOK_PLUS_ASSIGN:
          codegen_emit_add(gen, expr->assign.lvalue->var_ref.name, old_value, rvalue_var);
          break;
        case TOK_MINUS_ASSIGN:
          codegen_emit_sub(gen, expr->assign.lvalue->var_ref.name, old_value, rvalue_var);
          break;
        case TOK_MUL_ASSIGN:
          codegen_emit_mul(gen, expr->assign.lvalue->var_ref.name, old_value, rvalue_var);
          break;
        case TOK_DIV_ASSIGN:
          codegen_emit_div(gen, expr->assign.lvalue->var_ref.name, old_value, rvalue_var);
          break;
        case TOK_MOD_ASSIGN:
          codegen_emit_mod(gen, expr->assign.lvalue->var_ref.name, old_value, rvalue_var);
          break;
        default:
          codegen_error(gen, "Unsupported assignment operator", expr->pos);
          return ORION_ERROR_CODEGEN;
      }
    }
    
    // Assignment expression evaluates to the assigned value
    codegen_emit_mov(gen, dest_var, expr->assign.lvalue->var_ref.name);
  } else {
    codegen_error(gen, "Invalid lvalue in assignment", expr->pos);
    return ORION_ERROR_CODEGEN;
  }
  
  return ORION_SUCCESS;
}
