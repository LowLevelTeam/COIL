# COIL Assembly: A Text Representation for Documentation and Implementation

## 1. Introduction

The Computer Oriented Intermediate Language (COIL) is fundamentally a **binary instruction format** designed to be generated by compilers and processed by COIL processors. While the binary format is the primary representation, this document defines "COIL Assembly" (COIL-ASM), a human-readable text representation of COIL that serves as:

1. A documentation tool for examples and specifications
2. A source format for assemblers and disassemblers
3. A debugging representation for COIL tools
4. A teaching aid for understanding COIL concepts

## 2. Relationship to COIL Binary Format

COIL-ASM provides a direct mapping to the underlying COIL binary format:

- Each COIL-ASM instruction corresponds to exactly one COIL binary instruction
- All COIL binary features are expressible in COIL-ASM
- The mapping between COIL-ASM and binary is deterministic and bidirectional

This close relationship ensures that tools can reliably convert between the two formats without information loss.

## 3. COIL-ASM Syntax

### 3.1 General Syntax Rules

```
; Comment starts with semicolon
INSTRUCTION operand1, operand2  ; Each instruction on its own line

; Directives start with a period
.PROC PROC_CPU
.ARCH ARCH_X86, ARCH_MODE_X86_64

; Symbols are defined with the SYM instruction
SYM symbol_name

; Labels end with a colon
label_name:
    INSTRUCTION operand1, operand2
```

### 3.2 Instruction Format

Instructions consist of:
1. An opcode mnemonic (e.g., `MOV`, `ADD`)
2. Zero or more operands, separated by commas
3. Optional condition suffix separated by underscore (e.g., `ADD_EQ`, `BR_GT`)

```
; Basic instruction format
OPCODE operand1, operand2, ...

; With condition suffix
OPCODE_CONDITION operand1, operand2, ...
```

### 3.3 Type System Representation

Types are expressed using descriptive identifiers:

```
; Basic types
TYPE_INT32          ; 32-bit signed integer
TYPE_UNT64          ; 64-bit unsigned integer
TYPE_FP32           ; 32-bit floating point

; Register types with register specifier
TYPE_RGP=RAX        ; General purpose register RAX
TYPE_RFP=XMM0       ; Floating point register XMM0
TYPE_RV=YMM1        ; Vector register YMM1

; Type extensions
TYPE_INT32+CONST    ; Constant integer
```

### 3.4 Memory References

Memory references use a bracket notation with optional base register, index register, scale, and displacement:

```
; Basic memory reference
[address]           ; Direct memory reference

; Register-based address
[TYPE_RGP=RAX]      ; Memory at address in RAX

; With index and scale
[TYPE_RGP=RAX + TYPE_RGP=RCX*4]  ; Base + Index*Scale

; With displacement
[TYPE_RGP=RBP + 8]  ; Base + Displacement
[symbol + 16]       ; Symbol + Displacement

; Full form
[TYPE_RGP=RAX + TYPE_RGP=RCX*4 + 16]  ; Base + Index*Scale + Displacement
```

### 3.5 Constants and Literals

```
; Numeric literals
42                  ; Decimal integer
0xFF                ; Hexadecimal integer
3.14159             ; Floating point

; String literals
"Hello, World"      ; String (array of bytes)
```

### 3.6 Directives

Directives control the assembler behavior:

```
; Processor selection
PROC PROC_CPU               ; CPU
PROC PROC_GPU               ; GPU (reserved for v3)

; Architecture selection
ARCH ARCH_X86, ARCH_MODE_X86_64    ; x86-64
ARCH ARCH_ARM, ARCH_MODE_ARM64     ; ARM64
ARCH ARCH_RISCV, ARCH_MODE_RV64    ; RISC-V 64-bit

; Section definition
SECTION .text, SECTION_ATTR_EXEC | SECTION_ATTR_READ  ; Code section
SECTION .data, SECTION_ATTR_READ | SECTION_ATTR_WRITE ; Data section

; Alignment
ALIGN 16            ; Align to 16-byte boundary

; Data definition
DATA TYPE_INT32, 42         ; Define 32-bit integer
DATA TYPE_ARRAY=TYPE_UNT8, "Hello"  ; Define string
```

### 3.7 Symbol References

```
; Define a symbol
SYM function_name, TYPE_PARAM0=SYMBOL_PARAM_GLOB  ; Global symbol

; Reference a symbol
CALL function_name          ; Call a function
MOV TYPE_RGP=RAX, variable  ; Load a variable address
```

### 3.8 Conditional Assembly

```
; Conditional assembly
IF ARCH == ARCH_X86
    ; x86-specific code
ELIF ARCH == ARCH_ARM
    ; ARM-specific code
ELSE
    ; Generic code
ENDIF
```

## 4. Detailed Encoding Examples

### 4.1 Basic Instruction

```
; COIL-ASM:
MOV TYPE_RGP=RAX, 42

; Binary Encoding:
0x10                ; Opcode for MOV
0x02                ; Two operands
0x92 0x00           ; TYPE_RGP with register ID for RAX
0x13 0x20           ; TYPE_UNT32 with TYPEEXT_IMM
0x2A 0x00 0x00 0x00 ; Value 42 (little-endian)
```

### 4.2 Conditional Instruction

```
; COIL-ASM:
ADD_EQ TYPE_RGP=RAX, TYPE_RGP=RBX

; Binary Encoding:
0x60                ; Opcode for ADD
0x03                ; Three operands (including condition)
0x92 0x00           ; TYPE_RGP with register ID for RAX 
0x92 0x01           ; TYPE_RGP with register ID for RBX
0xF0 0x00           ; TYPE_PARAM5 (condition parameter)
0x00 0x00 0x00 0x00 ; BRANCH_COND_EQ (0)
```

### 4.3 Memory Reference

```
; COIL-ASM:
MOV TYPE_RGP=RAX, [TYPE_RGP=RBX + TYPE_RGP=RCX*4 + 16]

; Binary Encoding:
0x10                ; Opcode for MOV
0x02                ; Two operands
0x92 0x00           ; TYPE_RGP with register ID for RAX
0xA6 0x00           ; TYPE_PTR (memory reference)
0x01                ; Base register present (RBX)
0x02                ; Index register present (RCX)
0x04                ; Scale factor 4
0x10 0x00 0x00 0x00 ; Displacement 16
```

## 5. Implementation Considerations

### 5.1 Assembler Implementation

A COIL assembler should:

1. Parse COIL-ASM syntax according to the rules in this document
2. Resolve symbols and calculate offsets
3. Generate the corresponding COIL binary format
4. Maintain debug information for mapping between source and binary

Recommended assembler architecture:
- Lexical analyzer for tokenizing input
- Recursive descent parser for syntax analysis
- Two-pass approach:
  - First pass: collect symbols and their definitions
  - Second pass: resolve references and generate code

### 5.2 Disassembler Implementation

A COIL disassembler should:

1. Parse COIL binary format
2. Identify instruction boundaries and operands
3. Map register IDs to register names
4. Generate readable COIL-ASM syntax
5. Include helpful comments and symbolic information when available

Recommended disassembler features:
- Symbol-aware disassembly for better readability
- Option to show instruction bytes alongside disassembly
- Cross-reference information for jump targets
- Structured representation of control flow

### 5.3 Integration with Development Tools

COIL-ASM should integrate with:

1. Source code editors (syntax highlighting, code completion)
2. Debuggers (source-level debugging, breakpoints)
3. Build systems (automated assembly and linking)
4. Analysis tools (static analysis, performance profiling)

## 6. Naming Conventions

Instead of using magic numbers, COIL-ASM implementations should use descriptive constants:

### 6.1 Processor Types

```
PROC_CPU = 0x01
PROC_GPU = 0x02  ; Reserved for v3
PROC_TPU = 0x03  ; Reserved for v3
PROC_DSP = 0x04  ; Reserved for v3
PROC_FPGA = 0x05  ; Reserved for v3
```

### 6.2 Architecture Types

```
ARCH_X86 = 0x01
ARCH_ARM = 0x02
ARCH_RISCV = 0x03
ARCH_MIPS = 0x04
ARCH_POWERPC = 0x05
```

### 6.3 Architecture Modes

```
; x86 modes
ARCH_MODE_X86_16 = 0x01  ; 16-bit mode (Real mode)
ARCH_MODE_X86_32 = 0x02  ; 32-bit mode (Protected mode)
ARCH_MODE_X86_64 = 0x03  ; 64-bit mode (Long mode)

; ARM modes
ARCH_MODE_ARM32 = 0x01  ; 32-bit mode (AArch32)
ARCH_MODE_ARM64 = 0x02  ; 64-bit mode (AArch64)

; RISC-V modes
ARCH_MODE_RV32 = 0x01  ; 32-bit mode (RV32)
ARCH_MODE_RV64 = 0x02  ; 64-bit mode (RV64)
ARCH_MODE_RV128 = 0x03  ; 128-bit mode (RV128)
```

### 6.4 Section Attributes

```
SECTION_ATTR_EXEC = 0x01  ; Executable
SECTION_ATTR_WRITE = 0x02  ; Writable
SECTION_ATTR_READ = 0x04  ; Readable
SECTION_ATTR_INIT = 0x08  ; Initialized data
SECTION_ATTR_UNINIT = 0x10  ; Uninitialized data
```

### 6.5 Symbol Parameters

```
SYMBOL_PARAM_TMP = 0x00  ; Symbol is used only in this context
SYMBOL_PARAM_FILE = 0x01  ; Symbol is used around the file
SYMBOL_PARAM_GLOB = 0x02  ; Symbol is used in other files
```

### 6.6 Branch Conditions

```
BRANCH_COND_EQ = 0x00  ; Equal
BRANCH_COND_NE = 0x01  ; Not equal
BRANCH_COND_GE = 0x02  ; Greater than or equal
BRANCH_COND_LT = 0x03  ; Less than
BRANCH_COND_GT = 0x04  ; Greater than
BRANCH_COND_LE = 0x05  ; Less than or equal
BRANCH_COND_Z = 0x06  ; Zero flag set
BRANCH_COND_NZ = 0x07  ; Zero flag not set
BRANCH_COND_C = 0x08  ; Carry flag set
BRANCH_COND_NC = 0x09  ; Carry flag not set
BRANCH_COND_O = 0x0A  ; Overflow flag set
BRANCH_COND_NO = 0x0B  ; Overflow flag not set
BRANCH_COND_S = 0x0C  ; Sign flag set
BRANCH_COND_NS = 0x0D  ; Sign flag not set
```

## 7. Best Practices

### 7.1 Code Organization

- Group related functions together
- Use sections appropriately for code, data, and BSS
- Maintain consistent indentation and formatting
- Use descriptive symbol names

### 7.2 Register Usage

- Follow ABI conventions for register usage
- Document register purpose with comments
- Minimize register spillage with careful planning
- Use platform-independent register references when possible

### 7.3 Memory Access

- Align data structures appropriately
- Use explicit types for memory accesses
- Be consistent with memory addressing patterns
- Document memory layout with comments

### 7.4 Portability

- Use conditional assembly for architecture-specific code
- Prefer platform-independent operations when possible
- Document architecture-specific assumptions
- Test on multiple target architectures

## 8. Tools Reference

The COIL toolchain includes:

1. **coilasm**: COIL assembler for converting COIL-ASM to COIL binary
   ```
   coilasm input.casm -o output.coil
   ```

2. **coildis**: COIL disassembler for converting COIL binary to COIL-ASM
   ```
   coildis input.coil -o output.casm
   ```

3. **coilobj**: COIL object utility for inspecting COIL binary files
   ```
   coilobj --info input.coil
   coilobj --symbols input.coil
   coilobj --sections input.coil
   ```

4. **coillink**: COIL linker for combining multiple COIL objects
   ```
   coillink input1.coil input2.coil -o output.coil
   ```

## 9. Example Programs

### 9.1 Hello World

```
; Hello World in COIL-ASM
PROC PROC_CPU
ARCH ARCH_X86, ARCH_MODE_X86_64

SECTION .data, SECTION_ATTR_READ | SECTION_ATTR_INIT
SYM hello_msg
DATA TYPE_ARRAY=TYPE_UNT8, "Hello, World!", 10, 0

SECTION .text, SECTION_ATTR_EXEC | SECTION_ATTR_READ
SYM _start, TYPE_PARAM0=SYMBOL_PARAM_GLOB
    ; Write to stdout
    MOV TYPE_RGP=RAX, 1         ; syscall: write
    MOV TYPE_RGP=RDI, 1         ; file descriptor: stdout
    MOV TYPE_RGP=RSI, hello_msg ; buffer
    MOV TYPE_RGP=RDX, 14        ; length
    SYSCALL

    ; Exit with code 0
    MOV TYPE_RGP=RAX, 60        ; syscall: exit
    MOV TYPE_RGP=RDI, 0         ; status code
    SYSCALL
```

```
; Realistc Hello World in COIL-ASM
PROC PROC_CPU
ARCH ARCH_X86, ARCH_MODE_X86_64

SECTION .data, SECTION_ATTR_READ | SECTION_ATTR_INIT
SYM hello_msg
DATA TYPE_ARRAY=TYPE_UNT8, "Hello, World!", 10, 0

SECTION .text, SECTION_ATTR_EXEC | SECTION_ATTR_READ
SYM _start, TYPE_PARAM0=SYMBOL_PARAM_GLOB
    VAR $0, TYPE_UINT64, 1
    VAR $1, TYPE_UINT64, 1
    VAR $2, TYPE_PTR, hello_msg
    VAR $3, TYPE_UINT64, 14
    SYSCALL abi-linux64 ($0, $1, $2, $3) ($0)

    ; Exit with code 0
    SYSCALL abi-linux64 (60, 0) ()
```


### 9.2 Function Implementation

```
; Calculate factorial in COIL-ASM
PROC PROC_CPU
ARCH ARCH_X86, ARCH_MODE_X86_64

SECTION .text, SECTION_ATTR_EXEC | SECTION_ATTR_READ
SYM factorial, TYPE_PARAM0=SYMBOL_PARAM_GLOB
    ; Function: unsigned long factorial(unsigned int n)
    ; Input: RDI = n
    ; Output: RAX = result
    
    ; Base case check
    CMP TYPE_RGP=RDI, 1
    BR_LE factorial_base_case
    
    ; Recursive case
    PUSH TYPE_RGP=RDI
    DEC TYPE_RGP=RDI
    CALL factorial
    POP TYPE_RGP=RDI
    MUL TYPE_RGP=RAX, TYPE_RGP=RDI
    RET
    
factorial_base_case:
    MOV TYPE_RGP=RAX, 1
    RET
```

## 10. Future Directions

COIL-ASM will continue to evolve alongside the COIL specification:

1. **COIL v2**: Will add standard library representations
2. **COIL v3**: Will add multi-device operations and syntax
3. **Tool Improvements**: Enhanced assembler/disassembler features
4. **IDE Integration**: Better development environment support