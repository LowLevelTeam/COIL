# COIL Assembly: A Text Representation for Documentation and Implementation

## 1. Introduction

The Computer Oriented Intermediate Language (COIL) is fundamentally a **binary instruction format** designed to be generated by compilers and processed by COIL processors. While the binary format is the primary representation, this document defines "COIL Assembly" (COIL-ASM), a human-readable text representation of COIL that serves as:

1. A documentation tool for examples and specifications
2. A source format for assemblers and disassemblers
3. A debugging representation for COIL tools
4. A teaching aid for understanding COIL concepts

## 1.5 Key Concepts

### Binary Format Primacy
COIL is fundamentally a **binary instruction format**. COIL Assembly (COIL-ASM) is a human-readable representation that maps directly to this binary format but is not the primary language of COIL. The binary format is the actual "language" of COIL.

### Type-Determined Instructions
Instructions derive their behavior from operand types rather than having many specialized opcodes. This allows for a compact instruction set while maintaining extensive capabilities.

### Variable System
COIL provides a robust variable system that abstracts over registers and memory:
- Variables are declared with specific types
- Variables can be scoped for automatic lifetime management
- The COIL processor optimally allocates variables to registers or memory
- Variables can be promoted or demoted as needed for performance

### ABI System
The Application Binary Interface (ABI) system eliminates the need for manual register handling during function calls:
- Parameter passing is automated based on ABI definitions
- Return values are managed according to ABI rules
- Register preservation is handled by the processor
- Multiple ABIs can coexist in the same program

## 2. Relationship to COIL Binary Format

COIL-ASM provides a direct mapping to the underlying COIL binary format:

- Each COIL-ASM instruction corresponds to exactly one COIL binary instruction
- All COIL binary features are expressible in COIL-ASM
- The mapping between COIL-ASM and binary is deterministic and bidirectional

This close relationship ensures that tools can reliably convert between the two formats without information loss.

## 3. COIL-ASM Syntax

### 3.1 General Syntax Rules

```
; Comment starts with semicolon
INSTRUCTION operand1, operand2  ; Each instruction on its own line

; Directives start with a period
.PROC PROC_CPU
.ARCH ARCH_X86, ARCH_MODE_X86_64

; Symbols are defined with the SYM instruction
SYM symbol_name

; Labels end with a colon
label_name:
    INSTRUCTION operand1, operand2
```

### 3.2 Instruction Format

Instructions consist of:
1. An opcode mnemonic (e.g., `MOV`, `ADD`)
2. Zero or more operands, separated by commas
3. Optional condition suffix separated by underscore (e.g., `ADD_EQ`, `BR_GT`)

```
; Basic instruction format
OPCODE operand1, operand2, ...

; With condition suffix
OPCODE_CONDITION operand1, operand2, ...
```

### 3.3 Type System Representation

Types are expressed using descriptive identifiers:

```
; Basic types
TYPE_INT32          ; 32-bit signed integer
TYPE_UNT64          ; 64-bit unsigned integer
TYPE_FP32           ; 32-bit floating point

; Register types with register specifier (use only when necessary)
TYPE_RGP=RAX        ; General purpose register RAX
TYPE_RFP=XMM0       ; Floating point register XMM0
TYPE_RV=YMM1        ; Vector register YMM1

; Type extensions
TYPE_INT32+CONST    ; Constant integer
```

### 3.4 Memory References

Memory references use a bracket notation with optional base register, index register, scale, and displacement:

```
; Basic memory reference
[address]           ; Direct memory reference

; Register-based address
[TYPE_RGP=RAX]      ; Memory at address in RAX

; With index and scale
[TYPE_RGP=RAX + TYPE_RGP=RCX*4]  ; Base + Index*Scale

; With displacement
[TYPE_RGP=RBP + 8]  ; Base + Displacement
[symbol + 16]       ; Symbol + Displacement

; Full form
[TYPE_RGP=RAX + TYPE_RGP=RCX*4 + 16]  ; Base + Index*Scale + Displacement
```

### 3.5 Constants and Literals

```
; Numeric literals
42                  ; Decimal integer
0xFF                ; Hexadecimal integer
3.14159             ; Floating point

; String literals
"Hello, World"      ; String (array of bytes)
```

### 3.6 Directives

Directives control the assembler behavior:

```
; Processor selection
PROC 0x01               ; CPU
PROC 0x02               ; GPU (reserved for v3)

; Architecture selection
ARCH 0x01, 0x03         ; x86-64
ARCH 0x02, 0x02         ; ARM64
ARCH 0x03, 0x02         ; RISC-V 64-bit

; Section definition
SECTION .text, 0x01 | 0x04  ; Code section
SECTION .data, 0x02 | 0x04 | 0x08 ; Data section

; Alignment
ALIGN 16            ; Align to 16-byte boundary

; Data definition
DATA TYPE_INT32, 42         ; Define 32-bit integer
DATA TYPE_ARRAY=TYPE_UNT8, "Hello"  ; Define string
```

### 3.7 Symbol References

```
; Define a symbol
SYM function_name, TYPE_PARAM0=0x02  ; Global symbol

; Reference a symbol
CALL function_name          ; Call a function
MOV variable, 42            ; Store value in a variable
```

### 3.8 Conditional Assembly

```
; Conditional assembly
IF ARCH == 0x01
    ; x86-specific code
ELIF ARCH == 0x02
    ; ARM-specific code
ELSE
    ; Generic code
ENDIF
```

## 4. Variable System

COIL's variable system is a key feature that distinguishes it from traditional assembly languages. Variables abstract away register allocation and memory management.

### 4.1 Variable Declaration

```
; Declare variables
VAR TYPE_INT32, counter, 0      ; Typed variable with initialization
VAR TYPE_FP64, pi, 3.14159      ; Floating point variable
VAR TYPE_PTR, data_pointer      ; Pointer variable, uninitialized
```

### 4.2 Variable Scoping

```
; Enter a scope
SCOPEE
    ; Variables declared here
    VAR TYPE_INT32, local_var, 0
    
    ; Nested scope
    SCOPEE
        VAR TYPE_INT32, inner_var, 0
    SCOPEL  ; inner_var destroyed here
    
SCOPEL  ; local_var destroyed here
```

### 4.3 Variable Access

```
; Direct usage (no register specification needed)
ADD counter, counter, 1
MOV result, counter

; Get address of variable
LEA addr_var, counter

; Indirect access
MOV [addr_var], 42
```

## 5. ABI System

The Application Binary Interface (ABI) system provides a platform-independent way to handle function calls, parameter passing, and return values.

### 5.1 Defining an ABI

```
ABI standard_x86_64
    PARAMS RAX, RDI, RSI, RDX, RCX, R8, R9
    RETS RAX, RDX
    CALLER RAX, RCX, RDX, RSI, RDI, R8, R9, R10, R11
    CALLEE RBX, RSP, RBP, R12, R13, R14, R15
    SALLIGN 16
    RZONE 128
EXIT
```

### 5.2 Using an ABI for Function Declaration

```
; Define a function with ABI
SYM add_function, TYPE_PARAM0=BRANCH_CTRL_ABI
    SCOPEE
    ; Get parameters
    VAR TYPE_INT32, a
    VAR TYPE_INT32, b
    MOV a, TYPE_PARAM0=BRANCH_CTRL_ABI_PARAM, 0  ; First parameter
    MOV b, TYPE_PARAM0=BRANCH_CTRL_ABI_PARAM, 1  ; Second parameter
    
    ; Calculate result
    VAR TYPE_INT32, result
    ADD result, a, b
    
    ; Return result
    RET TYPE_PARAM0=BRANCH_CTRL_ABI_RET, result
    SCOPEL
```

### 5.3 Calling a Function with ABI

```
; Call a function with parameters
VAR TYPE_INT32, x, 10
VAR TYPE_INT32, y, 20
CALL add_function, TYPE_PARAM0=BRANCH_CTRL_ABI_PARAM, x, y

; Get the return value
VAR TYPE_INT32, sum
MOV sum, TYPE_PARAM0=BRANCH_CTRL_ABI_RET
```

## 6. Detailed Encoding Examples

### 6.1 Basic Instruction

```
; COIL-ASM:
MOV TYPE_RGP=RAX, 42

; Binary Encoding:
0x10                ; Opcode for MOV
0x02                ; Two operands
0x92 0x00           ; TYPE_RGP with register ID for RAX
0x13 0x20           ; TYPE_UNT32 with TYPEEXT_IMM
0x2A 0x00 0x00 0x00 ; Value 42 (little-endian)
```

### 6.2 Variable Declaration and Usage

```
; COIL-ASM:
VAR TYPE_INT32, counter, 10
ADD counter, counter, 1

; Binary Encoding for VAR:
0x16                ; Opcode for VAR
0x03                ; Three operands
0x03 0x00           ; TYPE_INT32
0x91 0x00           ; TYPE_SYM for name
0x13 0x20           ; TYPE_UNT32 with TYPEEXT_IMM
0x0A 0x00 0x00 0x00 ; Value 10 (little-endian)

; Binary Encoding for ADD:
0x60                ; Opcode for ADD
0x03                ; Three operands
0x90 0x00           ; TYPE_VAR for destination
[var_id]            ; Variable ID for counter
0x90 0x00           ; TYPE_VAR for source1
[var_id]            ; Variable ID for counter
0x13 0x20           ; TYPE_UNT32 with TYPEEXT_IMM
0x01 0x00 0x00 0x00 ; Value 1 (little-endian)
```

### 6.3 ABI Function Call

```
; COIL-ASM:
VAR TYPE_INT32, x, 5
CALL add_function, TYPE_PARAM0=BRANCH_CTRL_ABI_PARAM, x

; Binary Encoding for CALL:
0x03                ; Opcode for CALL
0x03                ; Three operands
0x91 0x00           ; TYPE_SYM for function name
[sym_id]            ; Symbol ID for add_function
0xFE 0x00           ; TYPE_PARAM0
0x03 0x00 0x00 0x00 ; BRANCH_CTRL_ABI_PARAM
0x90 0x00           ; TYPE_VAR for x
[var_id]            ; Variable ID for x
```

## 7. Best Practices

### 7.1 Code Organization

- Group related functions together
- Use sections appropriately for code, data, and BSS
- Maintain consistent indentation and formatting
- Use descriptive symbol names

### 7.2 Variable Usage

- Use variables instead of direct register references whenever possible
- Properly scope variables to minimize resource usage
- Use appropriate variable types for better optimization
- Consider variable promotion/demotion for performance-critical code

### 7.3 ABI Usage

- Use the ABI system for all function calls
- Define custom ABIs only when necessary
- Document ABI requirements for external interfaces
- Use architecture-independent ABIs when possible

### 7.4 Memory Access

- Align data structures appropriately
- Use explicit types for memory accesses
- Be consistent with memory addressing patterns
- Document memory layout with comments

### 7.5 Portability

- Use conditional assembly for architecture-specific code
- Prefer platform-independent operations when possible
- Document architecture-specific assumptions
- Test on multiple target architectures

## 8. Tools Reference

The COIL toolchain includes:

1. **coilasm**: COIL assembler for converting COIL-ASM to COIL binary
   ```
   coilasm input.casm -o output.coil
   ```

2. **coildis**: COIL disassembler for converting COIL binary to COIL-ASM
   ```
   coildis input.coil -o output.casm
   ```

3. **coilobj**: COIL object utility for inspecting COIL binary files
   ```
   coilobj --info input.coil
   coilobj --symbols input.coil
   coilobj --sections input.coil
   ```

4. **coillink**: COIL linker for combining multiple COIL objects
   ```
   coillink input1.coil input2.coil -o output.coil
   ```

## 9. Example Programs

### 9.1 Hello World

```
; Hello World in COIL-ASM using variables and ABI
PROC 0x01                     ; CPU
ARCH 0x01, 0x03               ; x86-64

SECTION .data, 0x02 | 0x04 | 0x08
SYM hello_msg
DATA TYPE_ARRAY=TYPE_UNT8, "Hello, World!", 10, 0

SECTION .text, 0x01 | 0x04
SYM _start, TYPE_PARAM0=0x02
    SCOPEE
    ; Declare variables for syscall
    VAR TYPE_UNT64, syscall_write, 1
    VAR TYPE_UNT64, stdout_fd, 1
    VAR TYPE_PTR, message, hello_msg
    VAR TYPE_UNT64, message_len, 14
    
    ; Write to stdout using syscall
    SYSCALL abi-linux64 (syscall_write, stdout_fd, message, message_len) ()
    
    ; Exit with code 0
    VAR TYPE_UNT64, syscall_exit, 60
    VAR TYPE_UNT64, exit_code, 0
    SYSCALL abi-linux64 (syscall_exit, exit_code) ()
    SCOPEL
```

### 9.2 Function Implementation with Variable System

```
; Calculate factorial in COIL-ASM using variables and ABI
PROC 0x01                     ; CPU
ARCH 0x01, 0x03               ; x86-64

SECTION .text, 0x01 | 0x04
SYM factorial, TYPE_PARAM0=BRANCH_CTRL_ABI
    ; Function: unsigned long factorial(unsigned int n)
    SCOPEE
    ; Get input parameter
    VAR TYPE_UNT64, n
    MOV n, TYPE_PARAM0=BRANCH_CTRL_ABI_PARAM
    
    ; Base case check
    CMP n, 1
    BR_LE factorial_base_case
    
    ; Recursive case
    VAR TYPE_UNT64, n_minus_1
    SUB n_minus_1, n, 1
    
    ; Recursive call
    CALL factorial, TYPE_PARAM0=BRANCH_CTRL_ABI_PARAM, n_minus_1
    
    ; Get result and multiply
    VAR TYPE_UNT64, result
    MOV result, TYPE_PARAM0=BRANCH_CTRL_ABI_RET
    MUL result, result, n
    
    ; Return result
    RET TYPE_PARAM0=BRANCH_CTRL_ABI_RET, result
    SCOPEL
    
factorial_base_case:
    VAR TYPE_UNT64, result, 1
    RET TYPE_PARAM0=BRANCH_CTRL_ABI_RET, result
    SCOPEL
```

### 9.3 Architecture-Independent Example

```
; Platform-independent function using variables and ABI
PROC 0x01                     ; CPU

SECTION .text, 0x01 | 0x04
SYM add_integers, TYPE_PARAM0=BRANCH_CTRL_ABI
    SCOPEE
    ; Get parameters
    VAR TYPE_INT, a
    VAR TYPE_INT, b
    MOV a, TYPE_PARAM0=BRANCH_CTRL_ABI_PARAM, 0
    MOV b, TYPE_PARAM0=BRANCH_CTRL_ABI_PARAM, 1
    
    ; Add integers
    VAR TYPE_INT, result
    ADD result, a, b
    
    ; Return result
    RET TYPE_PARAM0=BRANCH_CTRL_ABI_RET, result
    SCOPEL
```

## 10. Comparison with Traditional Assembly

To highlight COIL's advantages, here's a comparison with traditional assembly:

### Traditional x86-64 Assembly:
```
; Function that adds two numbers in x86-64 assembly
add_function:
    ; Parameters in RDI, RSI per System V ABI
    ; Need to know register conventions
    mov rax, rdi      ; First parameter to RAX
    add rax, rsi      ; Add second parameter
    ret               ; Return in RAX
```

### COIL-ASM Equivalent:
```
; Same function in COIL with variables and ABI
SYM add_function, TYPE_PARAM0=BRANCH_CTRL_ABI
    SCOPEE
    ; Get parameters through ABI
    VAR TYPE_INT64, a
    VAR TYPE_INT64, b
    MOV a, TYPE_PARAM0=BRANCH_CTRL_ABI_PARAM, 0
    MOV b, TYPE_PARAM0=BRANCH_CTRL_ABI_PARAM, 1
    
    ; Add values (no register knowledge needed)
    VAR TYPE_INT64, result
    ADD result, a, b
    
    ; Return through ABI
    RET TYPE_PARAM0=BRANCH_CTRL_ABI_RET, result
    SCOPEL
```

### Advantages of COIL:
- Architecture-independent code
- No need to know register conventions
- Variables with automatic memory management
- Explicit parameter passing through ABI
- Same code works on any supported architecture