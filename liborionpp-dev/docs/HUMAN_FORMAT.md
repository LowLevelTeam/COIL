# Orion++ Language Specification

This document defines the complete syntax and semantics for Orion++ human-readable assembly format (.hopp files).

## Table of Contents

1. [Lexical Structure](#lexical-structure)
2. [File Structure](#file-structure)
3. [Variables](#variables)
4. [Symbols](#symbols)
5. [Functions](#functions)
6. [Instructions](#instructions)
7. [Control Flow](#control-flow)
8. [Data Types](#data-types)
9. [Sections](#sections)
10. [Parsing Guidelines](#parsing-guidelines)

## Lexical Structure

### Tokens

Orion++ uses the following token types:

```
COMMENT         ::= '//' [^\n]* | '/*' .* '*/'
IDENTIFIER      ::= [a-zA-Z_][a-zA-Z0-9_]*
VARIABLE        ::= '$' [0-9]+
SYMBOL          ::= '@"' ([^"\\] | '\\' .)* '"'
LABEL           ::= '.' IDENTIFIER ':'
INTEGER         ::= '-'? [0-9]+
DIRECTIVE       ::= '.' IDENTIFIER
SECTION_FLAG    ::= '[' IDENTIFIER ']'
NEWLINE         ::= '\n' | '\r\n'
WHITESPACE      ::= [ \t]+
```

### Comments

```assembly
// Single line comment extends to end of line
/* Multi-line comment can span
   multiple lines and contain /* nested */ comments */
```

**Parser Implementation Note**: Nested multi-line comments are supported. Maintain a counter for comment depth.

### Case Sensitivity

- **Instructions**: Case-insensitive (`isa.ADD` == `isa.add`)
- **Symbols**: Case-sensitive (`@"Main"` != `@"main"`)
- **Variables**: Case-sensitive (always numeric, so not applicable)
- **Labels**: Case-sensitive (`.L1` != `.l1`)

### Line Endings

Both Unix (`\n`) and Windows (`\r\n`) line endings are supported. Parsers should normalize to a single representation internally.

## File Structure

### File Organization

```assembly
// Optional file header comment
// Generated by Orion++ Compiler v2.0
// Target: x86_64-linux-gnu

// Section declarations (optional)
obj.section [EXEC] .text
obj.section [WRITE] .data

// Symbol and function definitions
obj.sym[global,func] @"main":
  // Function body
.hint-endfunc()

// Additional functions and data
```

### Parsing Order

1. **Tokenization**: Break input into tokens
2. **Section Processing**: Parse section declarations
3. **Symbol Resolution**: First pass to collect all symbols
4. **Function Parsing**: Parse function bodies
5. **Label Resolution**: Resolve label references
6. **Validation**: Type checking and constraint validation

## Variables

### Variable ID Ranges

| Range | Type | Description |
|-------|------|-------------|
| $1-$255 | Parameters | Function input parameters |
| $256-$65535 | Local Variables | Function-scoped variables |
| $65536+ | Temporaries | Compiler-generated temporaries |

### Variable Declaration

Variables are implicitly declared on first use:

```assembly
isa.const $1, 42        // Declares and initializes $1
isa.let $256, $1        // Declares $256, copies value from $1
```

### Variable Scope Rules

```assembly
obj.sym[global,func] @"example":
  abi.callee.enter
  isa.enter               // Start function scope
    // $1-$255: Parameters accessible here
    // $256-$65535: Local variables accessible here
    
    isa.enter             // Start nested scope
      // All outer variables still accessible
      // New locals can be declared
    isa.leave             // End nested scope
    
  isa.leave               // End function scope
  abi.callee.leave
```

**Parser Implementation**: Maintain scope stack to track variable visibility.

### Variable Type Inference

```assembly
isa.const $1, 42          // $1 inferred as i32
isa.const $2, -10         // $2 inferred as i32
isa.add $3, $1, $2        // $3 inferred as i32 (result of i32 + i32)
```

## Symbols

### Symbol Syntax

Symbols must be enclosed in `@"..."` with the following escape sequences:

| Escape | Character | Description |
|--------|-----------|-------------|
| `\"` | `"` | Double quote |
| `\\` | `\` | Backslash |
| `\n` | Newline | Line feed |
| `\r` | Carriage return | Carriage return |
| `\t` | Tab | Horizontal tab |
| `\0` | Null | Null character |
| `\uXXXX` | Unicode | Unicode code point (4 hex digits) |

### Symbol Examples

```assembly
@"simple_name"                    // Simple identifier
@"operator+"                      // Operator overloading
@"std::vector::push_back"         // C++ namespaced function
@"函数名"                         // Unicode function name
@"string with spaces"             // Spaces allowed
@"escape\"test"                   // Escaped quotes
@"file.cpp:123"                   // Debug information
```

### Symbol Visibility

```assembly
obj.sym[global,func] @"public_function":     // External linkage
obj.sym[local,func] @"internal_function":    // Internal linkage
obj.sym[weak,func] @"optional_function":     // Weak linkage
```

**Parser Implementation**: Build symbol table during first pass, resolve references during second pass.

## Functions

### Function Declaration Syntax

```assembly
obj.sym[VISIBILITY,TYPE] @"SYMBOL_NAME":
  .hint-abi(ABI_TYPE)
  .hint-args(ARG_TYPES...)
  .hint-rets(RETURN_TYPE)
  
  // Function prologue
  abi.callee.enter
  isa.enter
  
  // Function body
  // ... instructions ...
  
  // Function epilogue
  isa.leave
  abi.callee.leave
  isa.RET
.hint-endfunc()
```

### Function Components

#### Visibility Types
- `global`: Externally visible
- `local`: File scope only
- `weak`: Can be overridden

#### Symbol Types
- `func`: Function symbol
- `object`: Data symbol
- `section`: Section symbol

#### ABI Types
- `c`: Standard C calling convention
- `custom`: Implementation-defined convention

### Function Examples

#### Simple Function
```assembly
// int add(int a, int b) { return a + b; }
obj.sym[global,func] @"add":
  .hint-abi(c)
  .hint-args(i32, i32)
  .hint-rets(i32)
  
  abi.callee.enter
  isa.enter
    // Parameters are in $1, $2
    isa.let $256, abi.callee.getarg.0    // a = $1
    isa.let $257, abi.callee.getarg.1    // b = $2
    isa.add $258, $256, $257             // result = a + b
    abi.callee.setret.0 $258             // return result
  isa.leave
  abi.callee.leave
  isa.RET
.hint-endfunc()
```

#### Recursive Function
```assembly
// int factorial(int n) { return n <= 1 ? 1 : n * factorial(n-1); }
obj.sym[global,func] @"factorial":
  .hint-abi(c)
  .hint-args(i32)
  .hint-rets(i32)
  
  abi.callee.enter
  isa.enter
    isa.let $256, abi.callee.getarg.0    // n = arg[0]
    isa.const $257, 1                    // constant 1
    
    // if (n <= 1)
    isa.bgt $256, $257, .L_recursive
    
    // Base case: return 1
    abi.callee.setret.0 $257
    isa.jmp .L_end
    
  obj.label .L_recursive:
    // Recursive case: n * factorial(n-1)
    isa.sub $258, $256, $257             // n - 1
    
    // Call factorial(n-1)
    abi.caller.setup
    abi.caller.setarg.0 $258
    isa.call @"factorial"
    abi.caller.getret.0 $259             // result of factorial(n-1)
    abi.caller.cleanup
    
    // n * factorial(n-1)
    isa.mul $260, $256, $259
    abi.callee.setret.0 $260
    
  obj.label .L_end:
  isa.leave
  abi.callee.leave
  isa.RET
.hint-endfunc()
```

## Instructions

### Instruction Categories

#### Core Instructions
```assembly
isa.nop                              // No operation
isa.enter                            // Enter scope
isa.leave                            // Exit scope
isa.RET                              // Return from function
```

#### Variable Operations
```assembly
isa.const $dest, immediate           // Load constant
isa.let $dest, $src                  // Variable assignment
isa.mov $dest, $src                  // Move (alias for let)
```

#### Arithmetic Instructions
```assembly
isa.add $dest, $src1, $src2         // Addition
isa.sub $dest, $src1, $src2         // Subtraction
isa.mul $dest, $src1, $src2         // Multiplication
isa.div $dest, $src1, $src2         // Division
isa.mod $dest, $src1, $src2         // Modulo
isa.neg $dest, $src                 // Negation
```

#### Bitwise Instructions
```assembly
isa.and $dest, $src1, $src2         // Bitwise AND
isa.or $dest, $src1, $src2          // Bitwise OR
isa.xor $dest, $src1, $src2         // Bitwise XOR
isa.not $dest, $src                 // Bitwise NOT
isa.shl $dest, $src, $count         // Shift left
isa.shr $dest, $src, $count         // Shift right
```

#### Control Flow Instructions
```assembly
isa.jmp label                       // Unconditional jump
isa.call @"symbol"                  // Function call
isa.beq $src1, $src2, label         // Branch if equal
isa.bne $src1, $src2, label         // Branch if not equal
isa.blt $src1, $src2, label         // Branch if less than
isa.ble $src1, $src2, label         // Branch if less or equal
isa.bgt $src1, $src2, label         // Branch if greater than
isa.bge $src1, $src2, label         // Branch if greater or equal
isa.beqz $src, label                // Branch if zero
isa.bnez $src, label                // Branch if not zero
```

#### ABI Instructions
```assembly
abi.callee.enter                    // Function entry
abi.callee.leave                    // Function exit
abi.callee.getarg.N                 // Get Nth argument
abi.callee.setret.N $src            // Set Nth return value

abi.caller.setup                    // Prepare function call
abi.caller.cleanup                  // Clean up after call
abi.caller.setarg.N $src            // Set Nth argument
abi.caller.getret.N $dest           // Get Nth return value
```

### Instruction Operand Types

| Type | Format | Description | Example |
|------|--------|-------------|---------|
| Variable | `$N` | Variable reference | `$1`, `$256` |
| Immediate | `N` | Integer constant | `42`, `-10` |
| Symbol | `@"name"` | Symbol reference | `@"main"` |
| Label | `.name` | Label reference | `.L1`, `.loop_start` |

## Control Flow

### Labels

```assembly
obj.label .L1:                      // Numeric label
obj.label loop_start:               // Named label
obj.label .L_function_end:          // Descriptive label
```

**Parser Implementation**: Labels must be unique within function scope. Build label table during first pass.

### Structured Control Flow

#### If-Else Statement
```assembly
// if (a < b) { x = 1; } else { x = 2; }
    isa.bge $1, $2, .L_else         // Jump if a >= b
    // Then block
    isa.const $3, 1
    isa.jmp .L_endif
obj.label .L_else:
    // Else block
    isa.const $3, 2
obj.label .L_endif:
    // Continue...
```

#### While Loop
```assembly
// while (i < 10) { i++; }
obj.label .L_loop_condition:
    isa.const $10, 10
    isa.bge $1, $10, .L_loop_end    // Exit if i >= 10
    
    // Loop body
    isa.const $11, 1
    isa.add $1, $1, $11             // i++
    
    isa.jmp .L_loop_condition
obj.label .L_loop_end:
```

#### For Loop
```assembly
// for (int i = 0; i < 10; i++) { ... }
    isa.const $1, 0                 // i = 0
obj.label .L_for_condition:
    isa.const $10, 10
    isa.bge $1, $10, .L_for_end     // Exit if i >= 10
    
    // Loop body
    // ... loop content ...
    
    // Increment
    isa.const $11, 1
    isa.add $1, $1, $11             // i++
    isa.jmp .L_for_condition
obj.label .L_for_end:
```

## Data Types

### Type System

Orion++ uses a simple type system with optional type hints:

```assembly
.hint-args(null)                    // No arguments
.hint-args(i32)                     // Single i32 argument
.hint-args(i32, i32, i32)           // Multiple arguments
.hint-rets(void)                    // No return value
.hint-rets(i32)                     // i32 return value
```

### Supported Types

| Type | Description | Size | Range |
|------|-------------|------|-------|
| `void` | No value | 0 | N/A |
| `i32` | 32-bit signed integer | 4 bytes | -2^31 to 2^31-1 |

### Future Type Extensions

The type system is designed for extension:

```assembly
// Potential future types
.hint-args(i64, f32, ptr)           // 64-bit int, 32-bit float, pointer
.hint-rets(struct)                  // Structure return
```

## Sections

### Section Declaration

```assembly
obj.section [FLAGS...] section_name
```

### Section Flags

| Flag | Description |
|------|-------------|
| `EXEC` | Contains executable code |
| `WRITE` | Writable at runtime |
| `ALLOC` | Allocates memory |
| `MERGE` | Can be merged with similar sections |
| `STRINGS` | Contains string data |

### Standard Sections

```assembly
obj.section [EXEC] .text            // Executable code
obj.section [WRITE,ALLOC] .data     // Initialized data
obj.section [WRITE,ALLOC] .bss      // Uninitialized data
obj.section [ALLOC] .rodata         // Read-only data
obj.section [STRINGS] .strtab       // String table
```

## Parsing Guidelines

### Lexical Analysis

1. **Tokenization Strategy**: Use longest match principle
2. **Whitespace Handling**: Ignore whitespace except for line boundaries
3. **Comment Processing**: Remove comments during tokenization
4. **String Processing**: Handle escape sequences in symbol names

### Syntax Analysis

1. **Grammar Type**: Context-free grammar, suitable for LR/LALR parsing
2. **Error Recovery**: Implement error recovery at statement boundaries
3. **Precedence**: Instructions have equal precedence, processed sequentially

### Semantic Analysis

1. **Symbol Resolution**: Two-pass approach (declare, then resolve)
2. **Type Checking**: Validate operand types against instruction requirements
3. **Scope Validation**: Ensure variables are used within proper scope
4. **Label Validation**: Verify all label references have corresponding definitions

### Parser State Machine

```
INITIAL → SECTION_DECL → SYMBOL_DECL → FUNCTION_BODY → INSTRUCTION → ...
```

### Error Handling

#### Lexical Errors
- Unterminated string literals
- Invalid character sequences
- Malformed numeric literals

#### Syntax Errors
- Missing operands
- Invalid instruction names
- Mismatched scope delimiters

#### Semantic Errors
- Undefined variable references
- Undefined symbol references
- Type mismatches
- Scope violations

### Parser Implementation Template

```c
typedef struct {
  Token* tokens;
  size_t token_count;
  size_t current_token;
  SymbolTable* symbols;
  LabelTable* labels;
  ScopeStack* scopes;
  ErrorList* errors;
} Parser;

ParseResult parse_file(Parser* parser) {
  // Two-pass parsing
  if (!first_pass(parser)) return PARSE_ERROR;
  if (!second_pass(parser)) return PARSE_ERROR;
  return PARSE_SUCCESS;
}
```

This specification provides the complete foundation for implementing Orion++ parsers and tools while maintaining consistency across different implementations.