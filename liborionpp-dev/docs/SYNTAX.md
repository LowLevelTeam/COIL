# Orion++ Syntax Reference

This document describes the complete syntax for Orion++ assembly language in human-readable format (.hopp files).

## Overview

Orion++ is a device-agnostic intermediate representation designed for:
- **Optimization**: Multiple passes can optimize the IR before code generation
- **Compatibility**: Single IR works across different target architectures
- **Efficiency**: Numeric variable IDs and symbol references for performance

## File Structure

```assembly
// Comments start with //
/* Block comments supported */

// File header (optional)
// Generated by Orion++ Compiler
// ORION++ ISA Assembly Output

// Section declaration
obj.section [EXEC] .text

// Functions and code here...
```

## Variables

### Variable Syntax

Variables are referenced by numeric IDs prefixed with `$`:

```assembly
$1          // Variable ID 1
$256        // Variable ID 256
$65536      // Variable ID 65536
```

### Variable Types and Ranges

```assembly
// Parameters: $1-$255 (function parameters)
$1, $2, $3    // First three parameters

// Local variables: $256-$65535
$256, $257    // Local variables

// Temporary variables: $65536+
$65536        // Compiler-generated temporary
```

### Variable Operations

```assembly
// Create constant
isa.const $1, 42              // $1 = 42
isa.const $2, -10             // $2 = -10

// Variable assignment
isa.let $3, $1                // $3 = $1
isa.mov $4, $2                // $4 = $2 (alias for let)

// Arithmetic
isa.add $5, $1, $2           // $5 = $1 + $2
isa.sub $6, $1, $2           // $6 = $1 - $2
isa.mul $7, $1, $2           // $7 = $1 * $2
isa.div $8, $1, $2           // $8 = $1 / $2
isa.mod $9, $1, $2           // $9 = $1 % $2
isa.neg $10, $1              // $10 = -$1

// Bitwise operations
isa.and $11, $1, $2          // $11 = $1 & $2
isa.or $12, $1, $2           // $12 = $1 | $2
isa.xor $13, $1, $2          // $13 = $1 ^ $2
isa.not $14, $1              // $14 = ~$1
isa.shl $15, $1, $2          // $15 = $1 << $2
isa.shr $16, $1, $2          // $16 = $1 >> $2
```

## Symbols

### Symbol Syntax

Symbols are enclosed in `@"..."` to allow maximum flexibility:

```assembly
@"function_name"           // Simple function name
@"operator+"               // Operator overloading
@"std::vector::push_back"  // C++ namespaced function
@"_internal_helper"        // Private functions
@"global_variable"         // Data symbols
@"函数名"                  // Unicode names
```

### Symbol Types

```assembly
// Function symbols
obj.sym[global,func] @"main":
obj.sym[local,func] @"helper":
obj.sym[weak,func] @"optional_function":

// Object symbols (data)
obj.sym[global,object] @"global_data":
obj.sym[local,object] @"static_buffer":

// Section symbols
obj.sym[local,section] @".text":
```

### Symbol Visibility

- **global**: Visible across compilation units
- **local**: Visible only within current unit
- **weak**: Can be overridden by strong symbols

## Functions

### Function Declaration

```assembly
obj.sym[global,func] @"function_name":
  .hint-abi(c)                    // ABI type: c, custom
  .hint-args(i32, i32)            // Parameter types
  .hint-rets(i32)                 // Return type
  
  // Function body
  abi.callee.enter
  isa.enter
    // ... function code ...
  isa.leave
  abi.callee.leave
  isa.RET
.hint-endfunc()
```

### Function Examples

#### Simple Function

```assembly
// int add(int a, int b) { return a + b; }
obj.sym[global,func] @"add":
  .hint-abi(c)
  .hint-args(i32, i32)
  .hint-rets(i32)
  
  abi.callee.enter
  isa.enter
    // Get parameters
    isa.let $1, abi.callee.getarg.0    // a = arg[0]
    isa.let $2, abi.callee.getarg.1    // b = arg[1]
    
    // Perform addition
    isa.add $3, $1, $2                 // result = a + b
    
    // Set return value
    abi.callee.setret.0 $3             // return result
  isa.leave
  abi.callee.leave
  isa.RET
.hint-endfunc()
```

#### Function with No Parameters

```assembly
// int get_answer() { return 42; }
obj.sym[global,func] @"get_answer":
  .hint-abi(c)
  .hint-args(null)                     // No parameters
  .hint-rets(i32)
  
  abi.callee.enter
  isa.enter
    isa.const $1, 42                   // result = 42
    abi.callee.setret.0 $1             // return result
  isa.leave
  abi.callee.leave
  isa.RET
.hint-endfunc()
```

#### Void Function

```assembly
// void print_hello() { printf("Hello"); }
obj.sym[global,func] @"print_hello":
  .hint-abi(c)
  .hint-args(null)
  .hint-rets(void)                     // Void return
  
  abi.callee.enter
  isa.enter
    // Call printf (simplified)
    abi.caller.setup
    abi.caller.setarg.0 @"hello_string"
    isa.call @"printf"
    abi.caller.cleanup
  isa.leave
  abi.callee.leave
  isa.RET
.hint-endfunc()
```

## Control Flow

### Labels

```assembly
obj.label .L1:                         // Label definition
obj.label loop_start:                  // Named label
obj.label .L_end_if:                   // Conditional label
```

### Jumps

```assembly
// Unconditional jump
isa.jmp .L1                           // Jump to label

// Conditional jumps
isa.beq $1, $2, .L_equal             // Jump if $1 == $2
isa.bne $1, $2, .L_not_equal         // Jump if $1 != $2
isa.blt $1, $2, .L_less              // Jump if $1 < $2
isa.ble $1, $2, .L_less_equal        // Jump if $1 <= $2
isa.bgt $1, $2, .L_greater           // Jump if $1 > $2
isa.bge $1, $2, .L_greater_equal     // Jump if $1 >= $2

// Zero comparison
isa.beqz $1, .L_zero                 // Jump if $1 == 0
isa.bnez $1, .L_not_zero             // Jump if $1 != 0
```

### Control Flow Examples

#### If Statement

```assembly
// if (a < b) { ... } else { ... }
    isa.bge $1, $2, .L_else          // Jump to else if a >= b
    
    // Then block
    isa.const $3, 1
    isa.jmp .L_endif
    
obj.label .L_else:
    // Else block  
    isa.const $3, 0
    
obj.label .L_endif:
    // Continue...
```

#### While Loop

```assembly
// while (i < 10) { ... }
obj.label .L_loop_start:
    isa.const $10, 10                // Load constant 10
    isa.bge $1, $10, .L_loop_end     // Exit if i >= 10
    
    // Loop body
    isa.add $1, $1, 1                // i++
    
    isa.jmp .L_loop_start            // Continue loop
obj.label .L_loop_end:
```

## Function Calls

### ABI Operations

```assembly
// Caller side
abi.caller.setup                     // Prepare for call
abi.caller.setarg.0 $1               // Set first argument
abi.caller.setarg.1 $2               // Set second argument
isa.call @"function_name"            // Make the call
abi.caller.getret.0 $3               // Get return value
abi.caller.cleanup                   // Clean up call

// Callee side
abi.callee.enter                     // Function entry
isa.let $1, abi.callee.getarg.0      // Get first argument
isa.let $2, abi.callee.getarg.1      // Get second argument
// ... function body ...
abi.callee.setret.0 $3               // Set return value
abi.callee.leave                     // Function exit
```

### Function Call Example

```assembly
// result = add(5, 3)
    abi.caller.setup
    isa.const $10, 5
    isa.const $11, 3
    abi.caller.setarg.0 $10
    abi.caller.setarg.1 $11
    isa.call @"add"
    abi.caller.getret.0 $12          // result in $12
    abi.caller.cleanup
```

## Scope Management

```assembly
isa.enter                            // Enter new scope {
    // Local variables and code
    isa.const $256, 10
    isa.const $257, 20
isa.leave                            // Exit scope }
```

## Data Types

### Type Hints

```assembly
.hint-args(null)                     // No arguments
.hint-args(i32)                      // Single i32 argument
.hint-args(i32, i32, i32)            // Multiple arguments
.hint-rets(void)                     // Void return
.hint-rets(i32)                      // i32 return
```

### Supported Types

- **void**: No value
- **i32**: 32-bit signed integer
- More types may be added in future versions

## Sections

```assembly
obj.section [EXEC] .text             // Executable code section
obj.section [WRITE] .data            // Writable data section
obj.section [ALLOC] .bss             // Uninitialized data
```

### Section Flags

- **EXEC**: Section contains executable code
- **WRITE**: Section is writable
- **ALLOC**: Section occupies memory at runtime
- **MERGE**: Section can be merged with others
- **STRINGS**: Section contains strings

## Comments and Documentation

```assembly
// Single line comment

/* 
   Multi-line comment
   Can span multiple lines
*/

// Function documentation
// Description: Adds two integers
// Parameters: a (i32), b (i32)  
// Returns: Sum of a and b (i32)
obj.sym[global,func] @"add":
```

## Best Practices

### Variable Management

```assembly
// Use meaningful debug names in source
// $1 -> "param_count"
// $2 -> "loop_index"  
// $256 -> "result"
// $257 -> "temporary"
```

### Symbol Naming

```assembly
// Use descriptive names
@"calculate_factorial"               // Good
@"func1"                            // Bad

// Namespace functions
@"math::add"                        // C++ style
@"string_utils_concat"              // C style
```

### Code Organization

```assembly
// Group related functions
obj.sym[global,func] @"string_length":
obj.sym[global,func] @"string_concat":
obj.sym[global,func] @"string_compare":

// Use consistent formatting
isa.const $1, 10                    // Align operands
isa.add   $2, $1, $1               // for readability
```

## Error Handling

The assembler will report errors for:

- Invalid variable IDs
- Malformed symbol names
- Mismatched scope enter/leave
- Invalid instruction operands
- Undefined labels

Example error:
```
Error: Invalid variable reference '$abc' at line 15
Error: Undefined symbol @"unknown_function" at line 23
Error: Mismatched scope - extra isa.leave at line 45
```

## Examples

See the `examples/` directory for complete working examples:

- **basic_arithmetic.hopp**: Simple math operations
- **control_flow.hopp**: If statements and loops
- **function_calls.hopp**: Function definitions and calls
- **fibonacci.hopp**: Recursive function example
- **string_ops.hopp**: String manipulation functions