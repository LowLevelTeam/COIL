#include "../include/orionpp_writer.h"
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

static void* safe_malloc(size_t size) {
  void* ptr = malloc(size);
  if (!ptr && size > 0) {
    fprintf(stderr, "Fatal: Memory allocation failed\n");
    exit(1);
  }
  return ptr;
}

static void* safe_realloc(void* ptr, size_t size) {
  void* new_ptr = realloc(ptr, size);
  if (!new_ptr && size > 0) {
    fprintf(stderr, "Fatal: Memory reallocation failed\n");
    exit(1);
  }
  return new_ptr;
}

OrionPPWriter* orionpp_writer_create(FILE* output, OrionPPFormat format) {
  if (!output) return NULL;
  
  OrionPPWriter* writer = safe_malloc(sizeof(OrionPPWriter));
  memset(writer, 0, sizeof(OrionPPWriter));
  
  writer->context = orionpp_context_create();
  writer->output = output;
  writer->format = format;
  writer->in_function = false;
  writer->current_scope_id = 0;
  
  // Initialize instruction buffer for binary format
  if (format == ORIONPP_FORMAT_BINARY) {
    writer->instruction_capacity = 4096;
    writer->instructions = safe_malloc(writer->instruction_capacity);
  }
  
  // Initialize label tracking
  writer->labels.capacity = 128;
  writer->labels.names = safe_malloc(sizeof(char*) * writer->labels.capacity);
  writer->labels.offsets = safe_malloc(sizeof(uint32_t) * writer->labels.capacity);
  writer->labels.resolved = safe_malloc(sizeof(bool) * writer->labels.capacity);
  
  return writer;
}

void orionpp_writer_destroy(OrionPPWriter* writer) {
  if (!writer) return;
  
  orionpp_context_destroy(writer->context);
  free(writer->instructions);
  
  // Clean up labels
  for (size_t i = 0; i < writer->labels.count; i++) {
    free(writer->labels.names[i]);
  }
  free(writer->labels.names);
  free(writer->labels.offsets);
  free(writer->labels.resolved);
  
  free(writer);
}

static OrionPPError ensure_instruction_capacity(OrionPPWriter* writer, size_t additional) {
  if (writer->format != ORIONPP_FORMAT_BINARY) return ORIONPP_OK;
  
  if (writer->instruction_size + additional > writer->instruction_capacity) {
    while (writer->instruction_capacity < writer->instruction_size + additional) {
      writer->instruction_capacity *= 2;
    }
    writer->instructions = safe_realloc(writer->instructions, writer->instruction_capacity);
  }
  return ORIONPP_OK;
}

static OrionPPError emit_opcode(OrionPPWriter* writer, uint8_t opcode) {
  if (writer->format == ORIONPP_FORMAT_BINARY) {
    ensure_instruction_capacity(writer, 2);
    writer->instructions[writer->instruction_size++] = opcode;
    writer->instructions[writer->instruction_size++] = 0; // flags
  }
  return ORIONPP_OK;
}

static OrionPPError emit_operand_immediate(OrionPPWriter* writer, int32_t value) {
  if (writer->format == ORIONPP_FORMAT_BINARY) {
    ensure_instruction_capacity(writer, 5);
    writer->instructions[writer->instruction_size++] = ORIONPP_OPERAND_IMMEDIATE;
    memcpy(&writer->instructions[writer->instruction_size], &value, sizeof(int32_t));
    writer->instruction_size += sizeof(int32_t);
  }
  return ORIONPP_OK;
}

static OrionPPError emit_operand_variable(OrionPPWriter* writer, uint32_t var_id) {
  if (writer->format == ORIONPP_FORMAT_BINARY) {
    ensure_instruction_capacity(writer, 5);
    writer->instructions[writer->instruction_size++] = ORIONPP_OPERAND_VARIABLE;
    memcpy(&writer->instructions[writer->instruction_size], &var_id, sizeof(uint32_t));
    writer->instruction_size += sizeof(uint32_t);
  }
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_begin_program(OrionPPWriter* writer) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    fprintf(writer->output, "// Generated by Orion++ Compiler\n");
    fprintf(writer->output, "// ORION++ ISA Assembly Output\n\n");
    fprintf(writer->output, "obj.section [EXEC] .text\n\n");
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_end_program(OrionPPWriter* writer) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    fprintf(writer->output, "\n// End of program\n");
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_begin_function(OrionPPWriter* writer, const char* name,
                                          uint16_t param_count, uint8_t return_type) {
  if (!writer || !name) return ORIONPP_ERR_INVALID_FORMAT;
  
  writer->current_function_id = orionpp_begin_function(writer->context, name, param_count, return_type);
  writer->in_function = true;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    fprintf(writer->output, "obj.sym[global,func] @\"%s\":\n", name);
    fprintf(writer->output, "  .hint-abi(c)\n");
    
    if (param_count == 0) {
      fprintf(writer->output, "  .hint-args(null)\n");
    } else {
      fprintf(writer->output, "  .hint-args(");
      for (uint16_t i = 0; i < param_count; i++) {
        if (i > 0) fprintf(writer->output, ", ");
        fprintf(writer->output, "i32");
      }
      fprintf(writer->output, ")\n");
    }
    
    fprintf(writer->output, "  .hint-rets(%s)\n", 
            return_type == ORIONPP_TYPE_VOID ? "void" : "i32");
    fprintf(writer->output, "\n");
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_end_function(OrionPPWriter* writer) {
  if (!writer || !writer->in_function) return ORIONPP_ERR_INVALID_FUNCTION;
  
  OrionPPError error = orionpp_end_function(writer->context);
  if (error != ORIONPP_OK) return error;
  
  writer->in_function = false;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    fprintf(writer->output, ".hint-endfunc()\n\n");
  }
  
  return ORIONPP_OK;
}

uint32_t orionpp_writer_create_variable(OrionPPWriter* writer, OrionPPVariableType type,
                                       const char* debug_name, uint8_t data_type) {
  if (!writer) return 0;
  return orionpp_create_variable(writer->context, type, debug_name, data_type);
}

uint32_t orionpp_writer_create_temp(OrionPPWriter* writer, uint8_t data_type) {
  if (!writer) return 0;
  return orionpp_create_temp_variable(writer->context, data_type);
}

uint32_t orionpp_writer_add_symbol(OrionPPWriter* writer, const char* name, uint8_t type,
                                  uint8_t visibility, uint16_t section, uint32_t value, uint32_t size) {
  if (!writer) return 0;
  return orionpp_add_symbol(writer->context, name, type, visibility, section, value, size);
}

const char* orionpp_writer_create_label(OrionPPWriter* writer) {
  if (!writer) return NULL;
  
  static char label_buffer[32];
  snprintf(label_buffer, sizeof(label_buffer), ".L%u", writer->label_counter++);
  return strdup(label_buffer);
}

OrionPPError orionpp_writer_place_label(OrionPPWriter* writer, const char* label) {
  if (!writer || !label) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    fprintf(writer->output, "    obj.label %s:\n", label);
  } else {
    // Mark label as resolved in binary format
    for (size_t i = 0; i < writer->labels.count; i++) {
      if (strcmp(writer->labels.names[i], label) == 0) {
        writer->labels.offsets[i] = (uint32_t)writer->instruction_size;
        writer->labels.resolved[i] = true;
        break;
      }
    }
  }
  
  return ORIONPP_OK;
}

const char* orionpp_writer_variable_to_string(OrionPPWriter* writer, uint32_t var_id) {
  if (!writer) return NULL;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    const char* debug_name = orionpp_get_variable_debug_name(writer->context, var_id);
    if (debug_name) {
      return debug_name;
    } else {
      static char var_buffer[32];
      snprintf(var_buffer, sizeof(var_buffer), "$%u", var_id);
      return var_buffer;
    }
  }
  
  return NULL;  // Binary format doesn't need string representation
}

const char* orionpp_writer_format_symbol(OrionPPWriter* writer, const char* name) {
  if (!writer || !name) return NULL;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    static char symbol_buffer[256];
    snprintf(symbol_buffer, sizeof(symbol_buffer), "@\"%s\"", name);
    return symbol_buffer;
  }
  
  return name;  // Binary format uses string table
}

// Instruction emission functions
OrionPPError orionpp_writer_emit_nop(OrionPPWriter* writer) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    fprintf(writer->output, "    isa.nop\n");
  } else {
    emit_opcode(writer, ORIONPP_OP_NOP);
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_enter(OrionPPWriter* writer) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    fprintf(writer->output, "  isa.enter // {\n");
  } else {
    emit_opcode(writer, ORIONPP_OP_ENTER);
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_leave(OrionPPWriter* writer) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    fprintf(writer->output, "  isa.leave // }\n");
  } else {
    emit_opcode(writer, ORIONPP_OP_LEAVE);
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_ret(OrionPPWriter* writer) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    fprintf(writer->output, "    isa.RET\n");
  } else {
    emit_opcode(writer, ORIONPP_OP_RET);
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_let(OrionPPWriter* writer, uint32_t dest, uint32_t src) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    const char* dest_str = orionpp_writer_variable_to_string(writer, dest);
    const char* src_str = orionpp_writer_variable_to_string(writer, src);
    fprintf(writer->output, "    isa.let %s, %s\n", dest_str, src_str);
  } else {
    emit_opcode(writer, ORIONPP_OP_LET);
    emit_operand_variable(writer, dest);
    emit_operand_variable(writer, src);
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_const(OrionPPWriter* writer, uint32_t dest, int32_t value) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    const char* dest_str = orionpp_writer_variable_to_string(writer, dest);
    fprintf(writer->output, "    isa.const %s, %d\n", dest_str, value);
  } else {
    emit_opcode(writer, ORIONPP_OP_CONST);
    emit_operand_variable(writer, dest);
    emit_operand_immediate(writer, value);
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_mov(OrionPPWriter* writer, uint32_t dest, uint32_t src) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    const char* dest_str = orionpp_writer_variable_to_string(writer, dest);
    const char* src_str = orionpp_writer_variable_to_string(writer, src);
    fprintf(writer->output, "    isa.mov %s, %s\n", dest_str, src_str);
  } else {
    emit_opcode(writer, ORIONPP_OP_MOV);
    emit_operand_variable(writer, dest);
    emit_operand_variable(writer, src);
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_add(OrionPPWriter* writer, uint32_t dest, uint32_t src1, uint32_t src2) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    const char* dest_str = orionpp_writer_variable_to_string(writer, dest);
    const char* src1_str = orionpp_writer_variable_to_string(writer, src1);
    const char* src2_str = orionpp_writer_variable_to_string(writer, src2);
    fprintf(writer->output, "    isa.add %s, %s, %s\n", dest_str, src1_str, src2_str);
  } else {
    emit_opcode(writer, ORIONPP_OP_ADD);
    emit_operand_variable(writer, dest);
    emit_operand_variable(writer, src1);
    emit_operand_variable(writer, src2);
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_sub(OrionPPWriter* writer, uint32_t dest, uint32_t src1, uint32_t src2) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    const char* dest_str = orionpp_writer_variable_to_string(writer, dest);
    const char* src1_str = orionpp_writer_variable_to_string(writer, src1);
    const char* src2_str = orionpp_writer_variable_to_string(writer, src2);
    fprintf(writer->output, "    isa.sub %s, %s, %s\n", dest_str, src1_str, src2_str);
  } else {
    emit_opcode(writer, ORIONPP_OP_SUB);
    emit_operand_variable(writer, dest);
    emit_operand_variable(writer, src1);
    emit_operand_variable(writer, src2);
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_call(OrionPPWriter* writer, const char* symbol) {
  if (!writer || !symbol) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    fprintf(writer->output, "    isa.call %s\n", orionpp_writer_format_symbol(writer, symbol));
  } else {
    emit_opcode(writer, ORIONPP_OP_CALL);
    uint32_t symbol_offset = orionpp_add_string(writer->context, symbol);
    ensure_instruction_capacity(writer, 5);
    writer->instructions[writer->instruction_size++] = ORIONPP_OPERAND_SYMBOL;
    memcpy(&writer->instructions[writer->instruction_size], &symbol_offset, sizeof(uint32_t));
    writer->instruction_size += sizeof(uint32_t);
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_beqz(OrionPPWriter* writer, uint32_t src, const char* label) {
  if (!writer || !label) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    const char* src_str = orionpp_writer_variable_to_string(writer, src);
    fprintf(writer->output, "    isa.beqz %s, %s\n", src_str, label);
  } else {
    emit_opcode(writer, ORIONPP_OP_BEQZ);
    emit_operand_variable(writer, src);
    // Add label to unresolved list
    // Implementation for label handling would go here
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_abi_callee_enter(OrionPPWriter* writer) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    fprintf(writer->output, "  abi.callee.enter\n");
  } else {
    emit_opcode(writer, ORIONPP_OP_ABI_CALLEE_ENTER);
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_abi_callee_leave(OrionPPWriter* writer) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    fprintf(writer->output, "  abi.callee.leave\n");
  } else {
    emit_opcode(writer, ORIONPP_OP_ABI_CALLEE_LEAVE);
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_abi_callee_getarg(OrionPPWriter* writer, uint32_t dest, int32_t index) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    const char* dest_str = orionpp_writer_variable_to_string(writer, dest);
    fprintf(writer->output, "    isa.let %s, abi.callee.getarg.%d\n", dest_str, index);
  } else {
    emit_opcode(writer, ORIONPP_OP_ABI_CALLEE_GETARG);
    emit_operand_variable(writer, dest);
    emit_operand_immediate(writer, index);
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_abi_callee_setret(OrionPPWriter* writer, uint32_t src, int32_t index) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    const char* src_str = orionpp_writer_variable_to_string(writer, src);
    fprintf(writer->output, "    abi.callee.setret.%d %s\n", index, src_str);
  } else {
    emit_opcode(writer, ORIONPP_OP_ABI_CALLEE_SETRET);
    emit_operand_immediate(writer, index);
    emit_operand_variable(writer, src);
  }
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_emit_comment(OrionPPWriter* writer, const char* comment) {
  if (!writer || !comment) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_HUMAN) {
    fprintf(writer->output, "// %s\n", comment);
  }
  // Binary format doesn't store comments
  
  return ORIONPP_OK;
}

OrionPPError orionpp_writer_finalize(OrionPPWriter* writer) {
  if (!writer) return ORIONPP_ERR_INVALID_FORMAT;
  
  if (writer->format == ORIONPP_FORMAT_BINARY) {
    // Write binary format header and data
    OrionPPHeader header = {0};
    header.magic = ORIONPP_MAGIC;
    header.version = ORIONPP_VERSION;
    header.flags = 0;
    header.next_var_id = orionpp_context_get_next_var_id(writer->context);
    
    // Calculate offsets
    size_t current_offset = sizeof(OrionPPHeader);
    
    header.string_table_offset = (uint32_t)current_offset;
    header.string_table_size = (uint32_t)orionpp_context_get_string_table_size(writer->context);
    current_offset += header.string_table_size;
    
    header.symbol_table_offset = (uint32_t)current_offset;
    header.symbol_table_size = (uint32_t)(orionpp_context_get_symbol_count(writer->context) * sizeof(OrionPPSymbol));
    current_offset += header.symbol_table_size;
    
    header.function_table_offset = (uint32_t)current_offset;
    header.function_table_size = (uint32_t)(orionpp_context_get_function_count(writer->context) * sizeof(OrionPPFunction));
    current_offset += header.function_table_size;
    
    header.variable_table_offset = (uint32_t)current_offset;
    header.variable_table_size = (uint32_t)(orionpp_context_get_variable_count(writer->context) * sizeof(OrionPPVariable));
    current_offset += header.variable_table_size;
    
    header.instruction_data_offset = (uint32_t)current_offset;
    header.instruction_data_size = (uint32_t)writer->instruction_size;
    
    header.entry_point = 0;  // First function
    
    // Write header
    fwrite(&header, sizeof(OrionPPHeader), 1, writer->output);
    
    // Write string table
    const char* string_table = orionpp_context_get_string_table(writer->context);
    size_t string_table_size = orionpp_context_get_string_table_size(writer->context);
    fwrite(string_table, 1, string_table_size, writer->output);
    
    // Write symbol table
    size_t symbol_count = orionpp_context_get_symbol_count(writer->context);
    if (symbol_count > 0) {
      const OrionPPSymbol* symbols = orionpp_context_get_symbols(writer->context);
      fwrite(symbols, sizeof(OrionPPSymbol), symbol_count, writer->output);
    }
    
    // Write function table
    size_t function_count = orionpp_context_get_function_count(writer->context);
    if (function_count > 0) {
      const OrionPPFunction* functions = orionpp_context_get_functions(writer->context);
      fwrite(functions, sizeof(OrionPPFunction), function_count, writer->output);
    }
    
    // Write variable table
    size_t variable_count = orionpp_context_get_variable_count(writer->context);
    if (variable_count > 0) {
      const OrionPPVariable* variables = orionpp_context_get_variables(writer->context);
      fwrite(variables, sizeof(OrionPPVariable), variable_count, writer->output);
    }
    
    // Write instruction data
    if (writer->instruction_size > 0) {
      fwrite(writer->instructions, 1, writer->instruction_size, writer->output);
    }
  }
  
  return ORIONPP_OK;
}