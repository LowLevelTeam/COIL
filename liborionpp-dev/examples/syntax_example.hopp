// Single Line Comment
/* 
Multi 
Line 
Comment 
*/

FEATURES {
  /* 
    Currently available features
      HINT - no functionality by itself but includes helpful hints for optimization and safety
      OBJ - Functionality to define the object structure (if not used then the output will just be a big binary of direct translations)
      ISA - The standard orionpp instruction set which can support basic arithmetic, control flow and memory.
      ABI - ABI Calling Convention definitions to help with function definitions. (defines functionality to define custom ABIs and standard ABIs)
    To exist in future development
      C - This is C language helpers with C primitive type definitions and more help for C compilers.
      ...More Coming Soon...
  */

  OBJ // (obj.*)
  ISA // (isa.*)
  ABI // (abi.*)
  HINT // (hint.*)  
}


// obj.section {TEXT|DATA|BSS|SYMTAB|STRTAB} [{WRITE|ALLOC|MERGE}...] "SECTION"
// translates to orion object section types (ORIONPP_TEXT,DATA,BSS,SYMTAB,STRTAB)
obj.section TEXT [] ".text"

// define symbol at program location
// obj.sym {LOCAL|GLOBAL|WEAK} {NULL,OBJ,FUNC} "SYMBOL"
obj.sym GLOBAL FUNC "add"
  // callee (this) function utilizes system standard abi calling convention
  abi.callee(system)

  // abi.args [VARID...] defines variable identifiers for arguments (accept as many as the ABI supports)
  abi.args [0, 1]

  // abi.rets [VARID...] defines variable identifiers for returns (can return more then one if the ABI supports it)
  abi.rets [2]

  abi.callee.setup
  
  // track local variables
  isa.scope_enter
    // Example local variables
    isa.let $3
    isa.mov $3, d10 // d = decimal / base 10
    isa.const $4, 10

    // add the first and second argument then place into the return variable
    // the $2 variable will be returned by the abi in cleanup
    isa.add $2, $0, $1

    // Example for calling a function utilizing an abi
    // set the abi call
    // 
    abi.caller(system)
    abi.caller.args [$0, $1]
    abi.caller.rets [$2]
    abi.caller.setup // set args, stack allignment and red zone if needed plus anything else in the calling convention
      call @add@
    abi.caller.cleanup // clean everything up
  
    // example for branch control flow

    // to help with label resolving a prefix on the label for if it is placed below or above must be used
    isa.br.eq +.0, $0, $1 // if ($0 == $1) goto .0;
    // value is not eq

    // jmp is used for unconditional branching
    isa.jmp +.1

    // labels can override one another as they are expected to be local
    isa.label .0 // value is eq

    isa.label .1 // end of if

    // infinite loop example
    // do { ... } while ($0 == $1);
    isa.label .0
      // loop body
      
      isa.br.eq -.0, $0, $1

  // every variable decalred in the scope will be cleaned up automatically
  isa.scope_leave

  abi.callee.cleanup

  isa.ret
hint.symend;

// Values
//  $variable_id
//  @symbol@  (it needs the end @ as symbols could have spaces in their name also \@ should be used for writing an @symbol and \\ for backslashes)
//  %{base}[digits]
//    example: %d10 is decimal 10
//    specific bases %2-9-A-Z
//    special bases x (hex), d (decimal), o (octal), b (binary)
//  [{value}, ...]
//  .{label}

obj.section DATA [] ".data"

obj.sym GLOBAL OBJ "hello_world_str"
  .byte %x68 // h
  .byte %x77 // w
  .byte %x00 // \0
hint.symend;