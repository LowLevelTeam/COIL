// Orion++ Syntax Example
// This file demonstrates the new variable and symbol syntax


obj.section [EXEC] .text

// Simple addition function
// int add(int a, int b) { return a + b; }
obj.sym[global,func] @"add":
  .hint-abi(c)
  .hint-args(i32, i32)
  .hint-rets(i32)
  
  abi.callee.enter
  isa.enter
    // Get function parameters (old syntax used string names)
    isa.let $1, abi.callee.getarg.0    // $1 = parameter 'a'
    isa.let $2, abi.callee.getarg.1    // $2 = parameter 'b'
    
    // Perform addition using numeric variable IDs
    isa.add $3, $1, $2                 // $3 = $1 + $2
    
    // Return the result
    abi.callee.setret.0 $3
  isa.leave
  abi.callee.leave
  isa.RET
.hint-endfunc()

// Function with local variables
// int multiply_and_add(int x, int y) { 
//   int temp = x * y; 
//   return temp + 10; 
// }
obj.sym[global,func] @"multiply_and_add":
  .hint-abi(c)
  .hint-args(i32, i32)
  .hint-rets(i32)
  
  abi.callee.enter
  isa.enter
    // Parameters
    isa.let $1, abi.callee.getarg.0    // x
    isa.let $2, abi.callee.getarg.1    // y
    
    // Local variables start at $256+
    isa.mul $256, $1, $2               // temp = x * y
    isa.const $257, 10                 // constant 10
    isa.add $258, $256, $257           // result = temp + 10
    
    abi.callee.setret.0 $258
  isa.leave
  abi.callee.leave
  isa.RET
.hint-endfunc()

// Function demonstrating symbol usage
// int factorial(int n) {
//   if (n <= 1) return 1;
//   else return n * factorial(n - 1);
// }
obj.sym[global,func] @"factorial":
  .hint-abi(c)
  .hint-args(i32)
  .hint-rets(i32)
  
  abi.callee.enter
  isa.enter
    isa.let $1, abi.callee.getarg.0    // n
    
    // Check if n <= 1
    isa.const $256, 1
    isa.bgt $1, $256, .L_recursive     // if n > 1, go to recursive case
    
    // Base case: return 1
    isa.const $257, 1
    abi.callee.setret.0 $257
    isa.jmp .L_return
    
obj.label .L_recursive:
    // Recursive case: return n * factorial(n - 1)
    isa.sub $258, $1, $256             // n - 1
    
    // Call factorial(n - 1) using symbol syntax
    abi.caller.setup
    abi.caller.setarg.0 $258
    isa.call @"factorial"              // Symbol reference with @"name"
    abi.caller.getret.0 $259           // result of factorial(n-1)
    abi.caller.cleanup
    
    // Multiply n * factorial(n-1)
    isa.mul $260, $1, $259
    abi.callee.setret.0 $260
    
obj.label .L_return:
  isa.leave
  abi.callee.leave
  isa.RET
.hint-endfunc()

// Main function demonstrating function calls
obj.sym[global,func] @"main":
  .hint-abi(c)
  .hint-args(null)
  .hint-rets(i32)
  
  abi.callee.enter
  isa.enter
    // Call add(5, 3)
    abi.caller.setup
    isa.const $256, 5
    isa.const $257, 3
    abi.caller.setarg.0 $256
    abi.caller.setarg.1 $257
    isa.call @"add"                    // Symbol reference
    abi.caller.getret.0 $258           // result = 8
    abi.caller.cleanup
    
    // Call factorial(5)
    abi.caller.setup
    isa.const $259, 5
    abi.caller.setarg.0 $259
    isa.call @"factorial"              // Symbol reference
    abi.caller.getret.0 $260           // result = 120
    abi.caller.cleanup
    
    // Return 0
    isa.const $261, 0
    abi.callee.setret.0 $261
  isa.leave
  abi.callee.leave
  isa.RET
.hint-endfunc()

// Example with complex symbol names
obj.sym[global,func] @"std::string::length":
  .hint-abi(c)
  .hint-args(i32)
  .hint-rets(i32)
  
  abi.callee.enter
  isa.enter
    // Dummy implementation
    isa.const $1, 42
    abi.callee.setret.0 $1
  isa.leave
  abi.callee.leave
  isa.RET
.hint-endfunc()

// Example with operator overloading
obj.sym[global,func] @"operator+":
  .hint-abi(c)
  .hint-args(i32, i32)
  .hint-rets(i32)
  
  abi.callee.enter
  isa.enter
    isa.let $1, abi.callee.getarg.0
    isa.let $2, abi.callee.getarg.1
    isa.add $3, $1, $2
    abi.callee.setret.0 $3
  isa.leave
  abi.callee.leave
  isa.RET
.hint-endfunc()

// Example with Unicode function name
obj.sym[global,func] @"计算总和":
  .hint-abi(c)
  .hint-args(i32, i32)
  .hint-rets(i32)
  
  abi.callee.enter
  isa.enter
    isa.let $1, abi.callee.getarg.0
    isa.let $2, abi.callee.getarg.1
    isa.add $3, $1, $2
    abi.callee.setret.0 $3
  isa.leave
  abi.callee.leave
  isa.RET
.hint-endfunc()